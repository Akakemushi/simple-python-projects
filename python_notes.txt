For anyone reading this, these are just my personal notes as I get to know the Python language and how it is similar/different from Ruby/Javascript.

- Quick note about linux that I didn't know, folders and filenames are case sensitive in Linux.
- Another OS note, Windows uses backslashes to separate folders in a filepath, while Mac and Linux use forward slashes /.   huh. If you want your
  program to work on all systems, you'll have to handle both cases.
- pip is the package installer for Python. pip allows you to install additional Python libraries and packages from the Python Package Index (PyPI).
  It's useful for managing dependencies in Python projects. With pip, you can install packages like NumPy, Django, Flask, etc., by running commands
  such as       pip install package_name or  pip install --user package_name
- to run python programs, do   python3   followed by the filename in the command line
- the file extension for python is .py, and there is also .pyw, which won't show a terminal window when it runs.
- REPL  stands for  Read  Evaluate  Print  Loop,  and it's a way to execute python code typed into the console and get immediate results.
- To initiate REPL,   simply type   "python3"  with nothing after it in the console.  To exit,  either do ctrl + D  or type "exit()"
- BUT!  There is a BETTER version of REPL, which is running    "ipython3"  which gives you stuff like remembering previous commands, using tab, etc.
  Exiting ipython3 is the same as the previous.
- Python is NOT as smart as Ruby, and does not assume that a string + an integer = a string (implicitly converting the integer into a string for you.)
- the "+" operator works on strings for concatenation.
- the "*" operator works on strings for MULTIPLIED concatenation! Nifty.  "Bob" * 5  --> BobBobBobBobBob
- you can put as many * as you want in str * int expressions, and it doesnt matter if they're before or after the str (or both) however you can't
  mix different operators.  For example   10 // 2 * 1 * "Bob" will not work, as the // operator is present.
- python convention is to use underscores for variable names (but this textbook uses camelcase)
- you can do comparisons between ints and floats.   (eg.  14 == 14.00     would be true.)
- comparisons between strings and non-strings will always be False.
- ORDER OF OPERATIONS  1. Math (see syntax) and comparison operators evaluate. 2. "not" operators. 3. "and" operators.  4. "or" operators are last.
  2 + 2 == 4 and not 2 + 2 == 5 or 2 * 2 == 2 + 2
  2 + 2 == 4 and not 2 + 2 == 5 or 4 == 2 + 2
  4 == 4 and not 4 == 5 or 4 == 4
  True and not False or True
  True and True or True
  True or True
  True
- HOW BLOCKS OF CODE WORK IN PYTHON:
    Blocks begin when the indentation increases.
    Blocks can contain other blocks.
    Blocks end when the indentation decreases to zero or to a containing block's indentation.
    Example below:

    name = 'Mary'
    password = 'swordfish'
    if name == 'Mary':
      print('Hello, Mary')
        if password == 'swordfish':
          print('Access granted.')
        else:
          print('Wrong password.')
  Exceptions exist to this rule though, for example, you can have an array/list span across several lines, and Python is smart enough to know
  that the list is not done until it finds the closing bracket ]
  There is also an "override" method when you want to force a particularly long line of code to be on two lines for readability.  To do that,
  you can "pause" the line of code by ending the line with the backslash character   "\".  This tells Python that there is more to come on the next line.
- Libraries/modules are needed to access other functions in Python.  SEE LIBRARIES SECTION FOR LIST
  To include/access those functions in your program, you use the "import" keyword, the name of the module,
  and optionally, more module names separated by commas  DO NOT OVERWRITE MODULES BY GIVING YOUR FILES THE SAME NAME!!
- Keyword Arguments  ---  What is it?  Most arguments are identified by their POSITION in the parentheses, but keyword arguments are called by name
  right before the argument passed to them, like so...  print("Hello", end="")    <-- here "end" is an optional parameter being filled in. (If you careful
  to know, it declares what the final character(s) will be, replacing the default new line character. Another you could use with print() is the "sep" argument
  which replaces the default space with something else when multiple strings are given to print.
- Python Call stack is FILO, First in, Last out.  If a function calls another function, that second function is completed and returns before the first
  function can continue.  Pretty standard.  Terminology wise, when a new function is called, a "Frame Object" is added to the top of the stack.
- !!SCOPE!!   Variables that are assigned within a function call are in the "local" scope, while variables assigned OUTSIDE of any function are in the "global".
  A variable must be in one or the other, it cannot be in both.  THIS IS IMPORTANT!  Local code can READ global variables, but it cannot CHANGE/OVERWRITE
  global variables!  This means that it's technically okay to have a global and a local variable with the same name, as they won't interfere with one another.
  Finally, if you declare a local variable with the same name as a global, the local code will prioritize the local value over the global one, but if a
  variable name is used that has not yet been created locally, the function will assume its a global that you're talking about.
  Note: If you try to READ from the global version, then DECLARE the local version afterwards, you will get an error.  You can't do that.  It really is
  global or local ONLY. Not both.  There IS a way to modify global variable from the local scope, with the "global" keyword (explained later)
  BEST PRACTICE:  Even though you technically CAN use variables with the same name... don't.  It can get confusing which variable is being referenced.
  I don't think that's the case in Ruby... I think local code CAN overwrite globals.
- FORCING a GLOBAL   In regards to scope above, if you MUST alter a global variable from within a local scope, you can do so by invoking the "global" keyword.
  At the top of the function,   use the keyword "global" followed by the name of the global variable.   This sort of "imports" the actual global variable
  into the local scope, and from there, you can set its value to something else as normal.  Doing this will NOT create a local variable with that name.
- SEQUENCE DATA TYPES  Python has a few different sequence data types, which are lists, strings, range objects returned by range(), and tuples.  Many of The
  things you can do with lists can also be done with strings and other values of sequence types: indexing, slicing, using them with for loops, with len(),
  and with the in and not in operators.
- MUTABLE and IMMUTABLE DATA TYPES  Mutable things like lists can have values added, removed or changed.  These terms are important for the definition of
  "mutated", as "overwriting" means that the original is completely thrown out, and something entirely new replaces it.  Strings in Python are Immutable.
  That means that while you can READ specific parts of a string using indicies and slices, you cannot reassign just a part of the string... you have to
  reassign the whole thing.   name = "Jason"    name[2] = "x"   will NOT work.  You would need to do some splitting and concatenation for that, invoking
  new / temporary variables.  This will become important when dealing with "Passing References". In short, there are MUTABLE and IMMUTABLE areas in CPU memory.
- TUPLES  wft is a tuple?  Well it's basically the "IMMUTABLE" clone of the LIST data type.  They are created just like arrays, but with parentheses instead
  of square brackets.  greetings = ("sup", "hi", 3.5, -9).  You can read indexes and slices from tuples, just like lists, but you can't overwrite
  single indexes like you can with lists.    greeting[0] = "bro" will NOT work.     Also, if you need to create a tuple that only has one value in it,
  you'll need to follow that value with a comma, otherwise, Python will think you're just declaring a simple str, int, or float that happens to be inside
  some parentheses.  It has no way to distinguish parentheses used in math from tuple parentheses unless there's a comma inside.
  names = ("Jason",)  is a tuple,   names = ("Jason") is a string.   So why use these? Well, Python can implement some optimizations that make code using
  tuples slightly faster than code using lists.   It also indicates to others some sequential data that you don't intend to change.
- MEMORY IN PYTHON   Variables just store a reference to some value in memory, so when you make another variable reference a previous variable, you're
  actually assigning it the reference to that data, not the data itself.  So if later on you go and change what the first variable is set to, the first
  variable and the second variable will now be pointing to different places in memory.  Let me show you.
    spam = 42      spam points to where 42 is located in memory.
    cheese = spam       cheese points to where spam is CURRENTLY pointing to in memory, so 42.
    spam = 100     spam is now pointing to somewhere else in memory, where 100 is.  But cheese is still pointing to 42.
    spam   (outputs  100)
    cheese  (outputs   42)
  Interestingly enough, I tested this out in Ruby, and Ruby does the same thing, which I didn't know.
  What this means is that when spam was reassigned to 100 above, it did not "change" 42 into 100.  It opened up a new spot in memory, put 100 inside it,
  and referenced that instead.  The spot where 42 resides was left untouched.  Now, MUTABLE data DOES change that exact spot in memory, so anything else
  that references that spot will also "see" the change.  To play around with this, you can get the memory address of some value by
  doing id(variable or value here), and you'll get some arbitrary string of numbers representing the address (which will vary). Check this test out...
    In [2]: num = 12
    In [3]: id(num)
    Out[3]: 140228057547344
    In [4]: num2 = num
    In [5]: id(num2)
    Out[5]: 140228057547344     <--- num2's address is the same as num's
    In [6]: num = 42
    In [7]: id(num)
    Out[7]: 140228057548304     <---- num's addres changed...
    In [8]: id(num2)
    Out[8]: 140228057547344     <---- but num2's did not.
- PASSING LISTS/REFERENCES AS ARGUMENTS     This is an important concept to grasp in order to avoid difficult bugs dealing with memory and pointers.  So,
    when passing IMMUTABLE data types into functions/methods, you're usually fine because copies are made locally, which will not affect the global versions.
    However, when passing MUTABLE data types like lists, you're passing in the reference to the original value, and therefore any changes you make to
    that array locally, WILL CHANGE the original as well, since its referencing the same place in memory.  If you don't want that to happen, you have two
    choices: either convert the data to a type that is immutable (such as from list to tuple), or import the copy library and use copy.copy(list) to make
    a second list that you can safely manipulate without affecting the other one. (and if it's a list of lists, use copy.deepcopy(list) instead.)
- WRAPAROUND HACK (not really a python-specific thing, but I thought it was cool math hack.)  You can use the modulus operator (%) to get the value on the other
    side of an array or matrix.  Let's say you have an array of some length, say, 10.  Now let's say I want to find the values of indicies ADJACENT TO some
    specific index.   Well, if I'm at index 3, then I can find the adjacent ones by going to indicies i+1 and i-1, right?  But what if I'm at the start or
    end of the array?  If i = 0, what then?  I can find i + 1, but there's nothing at i - 1...  Well, we can "wrap around" to the end of the array (that is
    to say index 9) by using  (i - 1) % length.  I don't fully understand why, but when a negative number enters the equasion, the maximum the remainder can
    be becomes the divisor instead of the dividend.  Normally, (when working with positives), the remainder is how much of the dividend was left over when
    as much of it was divided as possible using the divisor.  So for 15 drinks / 6 people, we think of it as 15 drinks - 6 drinks = 9,  9 - 6 = 3, and we can't subtract/reduce
    give the remaining 3 away because everyone wouldn't get one because we don't have enough, so 3 is the remainder of 15, the dividend.  Likewise,
    if we try doing 4 / 10, we think of that as 4 - 10,     which is impossible right off the bat, leaving a remainder of 4.
    Again, it's the dividend.  When you throw a negative number in the mix though, things change.
    -1 % 10 for example leaves a remainder of 9, which is much larger than the dividend, but fits within the divisor. -11 % 10 and
    -101 % 10 also have a remainder of 9.  So while I don't quite understand why, it seems like you can essentially just take the remainder of the divisor?
      -1 % 10 = 9
    is functionally equivalent to...
      I have a -1 cubic foot hole to fill.  I have buckets which cointain 10 cubic ft of cement each.  When the hole is full, how much is left in
      the final bucket?  The answer would be 9 cubic feet. If it was -101 cubic feet, I would use 10 buckets, and 1 cubic foot from the final bucket,
      still leaving 9.
    all this is to say, this method works with all the other indicies, too.    i = 5? No problem.  (5 - 1) = 4  -->    4 / 10 would leave a remainder of 4.
- Chaining method calls.   You can chain method calls in Python just like in Ruby.  Something like myString.upper().lower() is valid.

SYNTAX NOTES
- Strings               Assignment is just like Ruby, use single or double quotes, with double quotes for using single quotes inside.
                        Escape character--   is the backslash character \.  use these
                            \' single quotes
                            \" double quotes
                            \t  tab
                            \n  newline
                            \\  backslash
                        Raw String-- You can convert a string to a "raw string" by puting an r before the initial quote.  Doing so will ignore all escape characters
                          and print exactly what you see. These are helpful if you want to type something that has a lot of backslashes such as a filepath
                          or perhaps url.
                        Multiline strings-- can be started with triple single quotes '''   ''' .  If you do this, you dont need to manually enter \n characters.
                          Multiline strings also accept both single and double quotes by default.  (Note that multiline comments follow a similar formula
                          using three double quotes """   """).
                        String slices-- can be taken just like arrays (below)  myString[3:7] myString[4:]   myString[:9]  etc.
                        String search-- can be done using   search_term in myString  or  search_term not in myString, just like arrays.
                        String interpolation--  There are TWO WAYS to do it in Python now, as of 3.6.  The first is the old way, which looks like this..
                          "This is the old style previous to %s %s." % ("coding_language", version_number)
                            In this version the %s converts whatever data type is sent to it into a string automatically, so you dont need to call str().
                          f"This is the new style of interpolation as of {coding_language} {verson_number}"
                            This is an f-string, and like raw-strings, you MUST HAVE the letter "f" written just before the initial quote mark.
                            as with #{variable} in Ruby, you can do operations and stuff within the {}.  Also, anything within the {} is converted to str.
                        String case--  myString.upper() and myString.lower() convert ALL the characters in the string to upper or lower. These methods do not
                          modify the original string: they return a new one, so you need to store it or set the original equal to the new one.
                          Two other relevant methods are   .islower() and .isupper()  which return T/F if the string is ALL upper or ALL lower.
                          Note, however that there MUST be at least one alphabet character within the string for this to return True. "12345".islower() will be False.
                        isX() methods-- These are various Boolean tests that look at the string and tell you if it matches a particular format.
                            isalpha()   Returns True if the string consists only of letters and isn't blank.
                            isalnum()   Returns True if the string consists only of letters and numbers and is not blank.
                            isdecimal() Returns True if the string consists only of numeric characters and is not blank.
                                        total misnomer here... only returns true if it's a positive whole number or 0.  "3.14" would be False.
                            isspace()   Returns True if the string consists only of spaces, tabs, and newlines and is not blank.
                            istitle()   Returns True if the string consists only of words that begin with an uppercase letter followed by only lowercase letters.
                                        note that this is sort of a misnomer.  Titles don't capitalize prepositions, but this method thinks they should be.
                        startswith()    takes a string as an argument and returns true or false depending on if the beginning of the string matches the argument.
                        endswith()      same, but matches the end of the string.   These two are useful alternatives to the == operator if you dont need to compare
                                        the entire string.
                        join()      !!! Ruby is different !!! If you have a list (array) of strings that need to be joined together.
                                    In Ruby, this is an array method...   myArray.join(" "), but in Python, this is a STRING method, so the syntax is reversed...
                                    " ".join(myArray)   This would be easy to overlook, so WATCH OUT
                        split()     This is the same as Ruby.  myString.split("some_delimiter") will output a list/array.  If left blank, the default is whitespace.
                                    You can use it to split text by newline characters.
                        partition()     This is new to me.  It takes a string argument to be used like a delimiter, but what it returns is not like .split.
                                        It returns a TUPLE with 3 parts, the first is the "before the partition", the second is the partition itself, and the
                                        third is "after the partition".  It will never return more than 3 parts, even if more than one instance of the partition
                                        is found in the string.  It will use the first one and ignore the rest.  It's a little weird, so as an example,
                                        "I am the king of France".partition("the") would return a tuple containing (("I am ", "the", "king of France"))
                                        Also, if the partition string does not occur in the string, then the first part of the tuple will be the whole string,
                                        and the other two will be blank.  I can't think of a reason to use this, but if you need to keep the partition itself
                                        for some reason, I guess this could be useful?
                                        You can use the multiple assignment trick to catch all three parts into variables like so...
                                        before, partition, after = "This is a test".partition("is")
                        justify methods ---   There are 3 methods that can be used to justify the console output of Python.
                            rjust()     Justify right.  Takes an integer argument that represents the TOTAL WIDTH of the output in the console,
                                        then adds spaces to the left of the string its called on until that total width is reached.  So, if you did, say...
                                        "Hello".rjust(20),    you would get and output of "               Hello", that is, 15 spaces + 5 characters to make 20.
                            ljust()     Justify left.  Same as above, but left.  Duh.
                            center()    Justify center.  You guessed it.
                            Note that you technically CAN put a value that is less than the string length, but no spaces will be added, so it's pointless.
                            Note also that you can add a second argument to change the default (spaces) to some other string or character. center(20, "*") for example.
                        strip methods  --- Used when you want to remove the whitespace from a string (space, tab, newline).
                            strip()     This exists in Ruby, too.  It just returns a string that has all the leading and trailing whitespace removed.
                            rstrip()    Removes whitespace on the right side.
                            lstrip()    Removes whitespace on the left side.
                            Optionally, you can add a string argument into any of these methods.  By doing so, you'll strip away ANY CONSECUTIVE OCCURANCES of ANY
                            of those characters, regardless of order.  Eg., strip("dog") would strip away any lowercase "d", "o", or "g", it found as follows...
                            "odododgggCATgodgod".strip("dog")   outputs  -->    "CAT"    and
                            "ododRodgggCATgodgod".strip("dog")   outputs  -->   RodgggCAT  because that capital R breaks the consecutive string.
                        Unicode stuff  ---  when you need to get the unicode value of a character, or convert a unicode value into a character.
                            ord()       Takes a single-character string as an argument, and outputs the unicode point value of that character.
                                        Note that this is NOT a string method, it is a built-in Python function.
                            chr()       Opposite effect--  takes an integer representing the unicode value of some character, and outputs that character.
                            You might use these when you need to do math on letters... or order them... or something.... I dunno.
- Regex stuff           all regex patterns and functions are included in the "re" library, so you need to import that.
                        there is a free online regex tester for python at  https://pythex.org
              .compile  to make a regex object, call re.compile() on a string representing the regex.  You can catch the returned object in a variable
                            phoneNumRegex = re.compile(r'\d\d\d-\d\d\d-\d\d\d\d')   the "r" at the front means "raw string", and is used to ignore the escape characters.
                            there is an optional second argument you can pass to .compile after the regex...
                                add re.DOTALL (without quotes) to make the dot character also include newlines in its matches.
                                add re.I or re.IGNORECASE to make the search case insensitive.
                                add re.VERBOSE to make the regex ignore whitespace and comments inside the expression, which frees you up to spread a particularly long
                                  and complicated regex over multiple lines and comment on what each part of the regex does. USE TRIPLE QUOTES FOR THIS ''' '''
                                if for some reason you wanted to use 2 or even all 3 of these options, you can, but since the .compile method only accepts 2 arguments,
                                  you have to "trick the system" a bit, by separating the options with a pipe..   re.compile("string", re.I | re.DOTALL | re.VERBOSE)
              .search   to use a regex, call myRegexObject.search('This is a string you want to search through.").  You can catch the retuned "match object".
                        NOTE: the .search method only returns the FIRST match found, and ignores any other matches.
                            mo = phoneNumRegex.search('My number is 415-555-4242.')   (mo is shorthand for "match object")
              .findall  this is like search, but returns EITHER: a list of matches as STRINGS, OR: a list of TUPLES of strings if there are groups used in the regex pattern
              .sub      this is a substitution method for a regex object.  It takes two arguments, the first is the string you want to INSERT INSTEAD,
                        and the second is the string that you are going to run the find and replace on.  The search term itself is already in the regex object.
                        If you want to include the "found match" in the replacement, you can do that by putting the part of the match you want to include in a group.
                        Once you do, you can then refer to that bit of the match using \1, \2, \3, etc within the replacement string. It's a tad hard, so here's an example
                              agentNamesRegex = re.compile(r'Agent (\w)\w*')    <--- the regex looks for stuff like "Agent Jane"  'Agent Thomas", etc... and "captures"
                              the first letter of the name in the inner parentheses you see above (\w).  This letter can now be refered to by using \1
                              agentNamesRegex.sub(r'\1****', 'Agent Alice told Agent Carol that Agent Eve Knew Agent Bob was a double agent.')
                              this will output the first letter, followed by 4 asterix in any place where "Agent Something" occurs.
                              A**** told C**** that E**** knew B**** was a doulbe agent.
              .group    to view the contents of a match object, call myMatchObject.group() to get a string containing just the match. (Without using .group(),
                            what you will get is the match plus some other data about that match, like where it was found.)  if you have created multiple
                            groups with additional ( ) in your regex, you can use the plural form .groups() to see them all in a tuple.
                        - \ the escape character, needed if you want to match any of the following   .  ^  $  *  +  ?  {}  []  \  |  ()
                            I think this is kinda weird, since we're using r'regexhere' to get a raw string... so I thought that all the \ characters
                            would be ignored... My best guess as to why this works is because of the .compile method you have to use.  Maybe we need
                            to send a raw string to the compile method, and the compile method has its own way of escaping things??  I dunno.
                        - ( )  creates a group for using the .group method later on.  eg.  (r'(\d\d\d)-(\d\d\d-\d\d\d\d)')
                            with this pattern, you could later do mo.group(1) to get just the area code, or mo.group(2) to get just the local number.
                        - \d   matches a single digit, 0-9
                        - \D   matches any character that is NOT a numeric digit 0-9
                        - \w   matches any letter, numeric digit, or the underscore character, so a-zA-Z0-9_
                        - \W   matches any character that is NOT the above /w
                        - \s   matches any space, tab, or newline character (so whitespace)
                        - \S   matches any NON-whitespace character.  this is kinda like \w, but it would also include special characters like $#& etc.
                        - {3}  matches the pattern (or character) preceeding it exactly x number of times.  \d{3} is equivalent to \d\d\d
                              you can also specify a minimum, maximum or both number of times by including a comma.  {3,5}, {,5}, {3,}
                        - |    The pipe is basically like "or".  It will return the FIRST match it finds from either side of the pipe. Can be used in a group, too.
                              (r'Batman|Tina Fey')       (r'Bat(man|mobile|copter|bat)')  <-- would match Batman, Batmobile, Batcopter, and Batbat.
                        - ?    Question marks mean that the preceeding group/character is optional (0 or 1 instances).  (r'Bat(wo)?man') matches both Batman and Batwoman
                               HOWEVER!!  There is a SECOND use for question marks; when they follow a range, like {3,5}?  By using a ? after a range, it tells the regex
                               to be LAZY and not GREEDY.  (Greedy is the default behavior).  It will then match the shortest possible string.
                        - *    The asterix means "match 0 or more" (r'Bat(wo)*man')  could match  Batwowowowowoman
                        - +    The plus means "match 1 or more"  (r'Bat(wo)+man')  would match Batwowowowowoman, but NOT match Batman.
                        - []   square brackets are for character classes. [a-zA-Z]  or [0-5] for example.  They are customizable versions of stuff like \d or \w
                               Note that inside the char class, the normal regex symbols don't function as such, and you do not need to escape them, like \$
                               The exception being the hyphen, which works to set a range. If you want to SEARCH for a hyphen in a char class, put it as the first
                               character (maybe last as well?) in the class, so that it isn't between two other characters.
                        - ^    Carrats have TWO uses
                               1). a character class starting with a carrat is a NEGATIVE class, so it matches any character NOT in the class,
                               just like the capital classes \D \W and \S
                               2). a regex that starts with a carrat means that the regex must be at the START of the string for it to count.
                        - $    dollar signs work like the second use of carrats (above), except that the regex must be at the END of the string to count.
                               That means that if you use both a carrat and a dollar sign, the whole string must match the regex, and have nothing else.
                        - .    period is the wildcard.  Matches everything except for newline.
                               use  .* for a greedy match all, and .*? for a lazy match all.  Here's the difference... "<I love melons> in bed>"
                                    (r'<.*?>') would find  "<I love melons>" and then give up.
                                    (r'<.*>')  would look through everything, and find '<I love melons> in bed>' as the longest match
- printscreen =         print("")  single quotes also work.   integers without any quotes also work.
                        You can pass multiple strings to print(), separated by commas, and they will be printed, separated by a space.
                        You can override the default spaces and new line characters that the print() function adds by using the Keyword Arguments "sep" and "end"
                        respectively, like so....    print("Hello", end="")  <-- stops console from going to next line.   print("milk", "eggs", "spam", sep=", ")
                        will change   the output    "milk eggs spam"  into   "milk, eggs, spam"
- interpolation =       To do interpolation, use the symbols %s, %i, or %f directly within the string-- then, after the final quotation mark (but still within
                        the parentheses), type a   %    followed by ANOTHER set of parentheses within the first set of parentheses.
                        Inside of the secondary parentheses you should include (in order) the values that will be filled into the string.
                        The values provided as arguments can be either direct values (such as, 6,  3.14,  or "giraffe") or variable names.
- concatenation =       nothing new here.  Just use ' + ' between two strings.   "I am " + "Jason"
- operators =           same as usual, but there is ORDER OF OPERATION in python, and priority is as follows from top to bottom...
                            ( ) parentheses.  Things inside of parentheses are evaluated first.
                            **  exponent
                            %  modulus (aka remainder)
                            //  Integer division/floored quotient  (it's just division, but it drops the remainder, if one exists (aka rounds down))
                            /   division
                            *   multiplication (works on strings and arrays too)
                            -   subtraction
                            +   addition (also concatenation for strings and arrays)
                        SO  as an example,  7 - 3 ** 2  evaluates to -2, not 16, because the exponent is evaluated FIRST.
                        You can also STACK exponents, so 2 ** 2 ** 4  evaluates to 65536 (huge), not 256.  The last exponent is evaluated and THEN the result is
                        treated as the exponent to the next exponent.   There are also shortcuts, as with other languages, as follows:
                            += x  the  shorthand  for   num = num + x      (also works on strings!)
                            -= x
                            *= x      (also works on strings!)
                            /= x
                            %= x
- variables =           works like Ruby.  Just put the variable name = value.  You don't need to specify data type.  n = 3, name = "Bob"
                        naming restrictions.  1. alphanumeric and underscore only.  2. must not start with number 3. no spaces.
                        variable names are CaSe SeNsItIvE
                        you can delete a variable (and its value) using the keyword "del".  del variable_name (though there's rarely a need for this.)
                        There is a shortcut for assigning multiple variables at once, if you have an array(list) for them.  Basically, instead of this...
                            cat = ["fat", "gray", "loud"]
                            size = cat[0]
                            color = cat[1]
                            disposition = cat[2]
                        you could write this in 2 lines of code instead...
                            cat = ["fat", "gray", "loud"]
                            size, color, disposition = cat
                        Naturally, the order matters, and the number of variables MUST equal the number of list items.

- user input =          input()     you can add a message or question inside the parenthesis  input("What's your name?")
                        !!IMPORTANT!!   Input will ALWAYS be a string,
- string length =       len(var)   or   len("String literal")
- array length  =       len(array)   or    len([2, 3, 4, 5])
- arrays         =      arrays in Python are called "lists", and the array itself is the "list value", which can be confusing.
                        So for example   pets = ["dog", "cat", "sloth"]     the "list value" would be ["dog", "cat", "sloth"], since that is
                        the value of "pets".    Stuff inside the array are called "items", and they are separated by commas, as normal.
                        You can make a list of lists  [[1, 2, 3], ["dog", "cat", "hat"]].
                        Lists CAN contain items of different data types, so   list = ["apple", 3, 5.7] is fine.
                        Like Ruby, you can get the LAST item by doing   list[-1]  and so on going backwards.
                        You can concatenate and multiply lists just like you can with strings using + and *
- array slice        =  To get an array slice, the syntax is  array[1:5]   where the first is the start of the slice, and the second is the stop.
                        CAREFUL!  The second number means "go up to but NOT include this" Also, don't get confused and think that the second number
                        means the length of the slice... it doesn't.  You can set variable values with slices.  slice =  array[3:5]
                        Shortcuts -   by leaving out a number such as  [:5]  or  [3:]  you are telling Python that you want to start at the
                        beginning, or go all the way to the end, respectively.
- array item removal =  To delete a single item from an array, use the keyword  "del", followed by the index like so:   del  array[2]
                        all the items after that index get moved forward. You can also delete using slice notation (see above)
- array include?     =  Works like a boolean operator such as == or > .  use keywords "in" and "not in" like so:
                        "howdy" in ["hello", "hi", "howdy", "heyas"]    <-- this would evaluate to True.
- array iteration   =   I over an array with a for loop, like so:   for your_variable_name in name_of_array:  this is for_each in Ruby.
- each_with_index   =   In Python you can do something like.....  for i in range(len(array)):    and use "i" for the index number and data.
                        Alternatively, you can use the "enumerate() function like so:
                            for index, item in enumerate(array_name):
                              print("Index ") + str(index) + " in this list is: " + item
                        Note here that the words "index" and "item" have been used, but you could use any variable name.
- tuples            =   tuples are created just like lists/arrays, but with parentheses instead of square brackets. ("hi", "hello", "sup")
- hashes            =   in Python, hashes are called "DICTIONARIES", but function exactly the same way...
                        myDictionary = {'key1': 'value1', 'key2': 'value2'}
- accessing hashes  =   Again, same as Ruby.  myDictionary["someKey"]  will give you the value stored at that key, and like Ruby,
                        the key-value pairs are unordered, so two dictionaries with the same key-value pairs are equal to each other regardless of order.
                        You can use integers and floats as the keys for hash values.
- hash sub-types    =   Dictionaries (hashes) in python have subtypes for all the keys, all the values, and all the key-value pairs.  To get these
                        data types (known as dict_keys, dict_values, dict_items respectively), use the name of the dictionary  followed by
                        .keys(), .values(), or .(items) respectively.  What you get back is not an array (it is not mutable like an array),
                        but something more like it, and you can ITERATE over it like an array, which is what they are usually used for.
                        If you want to turn these 3 data types into an array, you can:  just do  list(name_of_dict_type), as you would for a tuple.
                        It should also be noted that the dict_items  type contains a sequence of tuples.
                        IMPORTANT NOTE* If you iterate over a hash that has two or more keys named the same, only the LAST one will be counted, and only
                        the LAST value will be assigned to that key.  So, myHash = {"name": "Bob", "name": "Jim"} will be length 1, and name = Jim.
- check for keys/values  =   In ruby, this would be   hash.has_key?(search_term), but in Python, this would be search_term in dictionary.keys()  ,
                        making use of the "in" or "not in" keywords.  There is also a shortcut for this, if you just omit the final   .keys() it does the same.
                        You can likewise use .values() to search for a value instead.  (There is no shortcut for values.)
- get hash values      =   This combines checking for the existance of a key AND fetching the value all in one.     Do   dictionary.get(key, fallback)
                          As the syntax implies, you need two arguments, the first is the key whose value you want, and the second is the default or
                          fallback value to use in the event that the key doesn't exist.
- set key-value default =  The syntax for this is    dictionary.setdefault("key", "default_value")    What this does is check that dictionary for that key,
                           and if the key doesn't exist, it creates it and sets its value to the default value.  However if the key DOES exist already,
                           it simply returns the value that's already stored (thus ignoring the second argument).  This could be useful when you want
                           to keep a running tally of various items, but you aren't sure just how many different items there are.  You can dynamically
                           do this with something like...
                           tally_keeper = {}
                              for thing in group:
                                tally_keeper.setdefault(thing, 0)   <-- if the thing has never before been seen in the group, it adds it and sets it to 0
                                tally_keeper[thing] += 1    <--  It increases the count of that thing by 1.
- PRETTY printing       =  (must import pprint library)  the pprint.pprint(data) function is just a more readable way to print hash data.  Prints each
                           key-value on a new line. If you want that output returned as a string instead, use pprint.pformat(data).
- string/float to int  =   int(string/float)        (in Ruby it's     .to_i)   NOTE: making a float an int will always round it down.
- int/float to string  =   str(int/float)               (in Ruby it's     .to_s)
- string/int to float  =   float(int/string)           (in Ruby it's    .to_f)   NOTE:  making an int a float will add a .0 at the end.
- string/tuple to list =   list(str/tuple)         (in Ruby it's   .to_a)
- list/string to tuple =   tuple(str/list)      (not in Ruby)
                         CAUTION!  Note that the above 5 type converters ONLY MAKE COPIES; you need to catch the return value in a variable.
- comments           =   Use a hashtag to denote comments in python     #  this is a comments
- rounding numbers  =    round(float)  rounds to closest integer.
- absolute value    =    abs(int or float)  will turn the number positive if it is negative.
- data type check   =    type(variable_name or value)
- booleans        =      assign with True    or   False.  fisrt letter MUST be capitalized, and you cannot use True  or  False as a variable name.
- comparisons     =      exactly the same as Ruby, Javascript, etc.     ==  !=   <    >   <=    >=
- &&              =      keyword   "and"
- ||              =      keyword   "or"
- !               =      keyword   "not"    not True    will evaluate to False.   not not not not True    will evaluate to True.
- conditionals    =      the condition followed by a COLON... (not curly brackets or parentheses)      if 5 > 4:    if "andy" == "tom":   else:
- if statements   =      Python uses  "if condition:"   "elif condition:"  and   "else:"
- while statements =     Use   "while condition:"
- break statement  =     just type the keyword  "break"  with nothing after it to exit a loop prematurely.
- (NEW!) continue  =     just type the keyword  "continue" with nothing after it.   What this does is jump to the START of the while loop prematurely.
- Falsey values    =     0  (an int)  0.0  (a float)  and  ''   (an empty string)   all evaluate to False in Python.
- For  loop        =     Example-     for i in range(5):          the part  "in range(5)"  is unique.   It sets the falue of i to 0 initially,
                         then counts 5 times, so i will equal    i = 0,  i = 1, i = 2, i = 3, i = 4   stop.
                         Note:  The "continue" statement in a For loop will ITERATE and then jump to the start.
                         Also, be careful... the variable name you give the incrementor (such as "i") is apparently VISIBLE to code OUTSIDE of that loop!
- More about range()  =  The range() function can have 1, 2, or 3 arguments.  If it has only 1 argument, then the range is assumed to start at 0, and
                         stops just before the argument given.  If TWO arguments are given, then the first argument becomes the STARTING point, and that
                         is used instead of 0.  If THREE arguments are used, the third argument is the "step" setting, or maybe think of it as the interval.
                         It's the number of steps that the iteration skips over.  Examples:
                         range(11) produces 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
                         range(5, 11) produces  5, 6, 7, 8, 9, 10   <---Note that it produces 5, but not 10.
                         range(5, 11, 2)  produces  5, 7, 9  <-----Note that "10" is not produced because the last "skip" would skip past the end.
                         This function is for int  only, it will not work with floats.  You can, however, use negative numbers, and even count backwards.
- random number          (must import random library) random.randint(start, end)  The arguments are inclusive, so the start and end numbers can appear as results.
- random array item      (must import random library) random.choice(array_name)
- shuffle array          (must import random library) random.shuffle(array_name) this shuffles the ORIGINAL array.  It doesn't make a copy.
- wait()                 (must import time library)  time.sleep(time in seconds)  argument is a float that represents seconds.
- copy()                 (must import copy library) makes a copy of a mutable data type.  The "why?" is more important than the "what" here. Info above.
- deepcopy()             (must import copy library) same as above, but works on lists with lists in them. (i.e., goes deeper, hence the name.)
- copy()                 (must import pyperclip library)  NOT THE SAME AS ABOVE!!!  This one accesses the computers clipboard.
- functions              =  use the "def" keyword, followed by the name of the function, parentheses, and a colon.     def hello():
                         To add parameters to your function, simply add one or more variable names in the parentheses, separated by commas.
                         It looks like you don't need to declare what data type your parameters can accept... HOWEVER, how those variables are used within
                         the function block will of course expect the values to be of a certain type... So it looks like it's up to the coder to keep
                         track of this.
- methods                just like a function, but it's called on a value.  This is very much like Ruby.  Call them with a dot "."  The main thing to
                         remember is that in Python, you need the closing parentheses, even if it's empty.  Each data type has its own built-in methods.
- array methods          FIND-- array.index("item_to_locate")    will return the index of the argument, if it exists (or the first instance of that argument
                            if duplicates exist.)
                         PUSH-- array.append(item_to_add)  adds the item to the end of the list. MODIFIES ORIGINAL LIST
                         INSERT AT--  array.insert(index, item_to_insert) the item will take over that position in the
                            index, and everything gets shoved over one from there. MODIFIES ORIGINAL LIST
                         DELETE-- array.remove(item_to_remove)   removes the item (if it exists, error otherwise) and moves everything to fill the gap.
                            (note that if you want to delete by INDEX and not VALUE, you need to use the "del" keyword function, detailed above.)
                            (note that if duplicates exist, only the FIRST instance will be deleted.) MODIFIES ORIGINAL LIST
                         POP--  array.pop()  does 2 things... it RETURNS the last item in the list, AND, it MODIFIES ORIGINAL LIST by deleting that last item.
                         SORT--  array.sort()  sorts the array.  Works on strings and numbers, BUT not on lists containing BOTH strings and numbers.
                            CAUTION!  This sorts things in ASCIIbetical order, so capitals will ALWAYS come before lower-case. If you want to avoid this,
                            , use the optional keyword argument (key=str.lower) This option will NOT affect the values, just the sorting.
                            There is an optional keyword argument available, (reverse=True) to sort a list in reverse order. MODIFIES ORIGINAL LIST
                         REVERSE--  array.reverse()  reverses the items in a list AS THEY ARE. (i.e., it doesn't sort them, so don't get confused.)
                            This is not the same thing as the keyword "reverse" mentioned in SORT.  MODIFIES ORIGINAL LIST
- return values       =  In Python, you must explicitly use the "return" keyword followed by a value or an expression (that will be evaluated).
                         Note that the "return" line immediately exits the function, ignoring anything below that line.
                         Note that you can pass return values as arguments to other functions.
                         Any function that does not explicitly return anything, will return "None" by default (see next).  Likewise, when "return" is used
                         without anything after it, the result will also be "None".
- Nil/Null            =  In Python, the "lack of any value" value is called "None" (with a capital N).  None is its own data type, and is the only value possible.
- Error Handling      =  Use the "try" and "except" statements.  Code that could potentially throw an error is put into a "try" clause.  Then, if an error
                         DOES occur, rather than crashing, the code moves to the following "except" block.  For example, try dividing by zero....
                         def spam(divided_by):
                             try:
                                 return 42 / divided_by
                             except ZeroDivisionError:
                                 print("Error: Invalid argument.")
                         Note: When an error does occur, the code does NOT jump back into the "try" block.  It just keeps going from the except block.
                         Also note that you need the NAME of the error to use the "except" clause.  Here are some names I've encountered.
                         ZeroDivisionError, UnboundLocalError, TypeError, SyntaxError, KeyboardInterrupt, ValueError, IndexError, AttributeError, KeyError
                         FileNotFoundError
- PyInputPlus methods =   (requires pyinputplus library) these are for data validation. Using these functions automatically strips away leading and
                          trailing whitespace.  They can all be given the following optional keyword arguments:
                              blank=True   this option will allow inputs to be blank.  The default is that an answer is required.
                              limit=5   this option limits the number of tries the user has to enter a valid input.
                              timeout=60   this option limits the amount of time (in seconds) that the user has to enter a valid input.
                              default='some default'  If this option is included along with limit or timeout, then the default value will be returned
                                  instead of throwing an error.  (it seems that your default value does NOT need to match the input data type.)
                              allowRegexes=[r'yourRegexGoesHere', r'anotherRegexGoesHere', r'etc']   This option will only allow inputs if they match
                                  one of the given regexes in the list. (You must give this method a LIST of regexes, even if it's only one.)
                              blockRegexes=[r'yourRegexGoesHere', r'anotherRegexGoesHere', r'etc']   Reverse of the above.
                                  If you use BOTH allowRegexes AND blockRegexes, the allowRegexes result will override the blocking one.
                          inputStr() it's like the built-in input() function but has the general PyInputPlus features. You can also pass a custom validation
                              function to it.
                          inputInt() Ensures the user enters an integer (not a float). Returns an int.
                          inputFloat() Ensures the user enters a float (not an int). Returns a float.  (technically you can enter ints without a decimal
                              and it will just add a .0  on the end for you.)
                          inputNum() Ensures the user enters a number.  Returns an int or float depending on input.
                              The above 3 number-related methods have additional options that can be added as a second argument...
                                  - min=4   set the minimum requirement for the input. inclusive.
                                  - max=4   set the maximum limit for the input. inclusive.
                                  - greaterThan=4  same as min, but exclusive.
                                  - lessThan=4  same as max, but exclusive.
                          inputChoice()  Ensures the user enters one of the provided choices.
                          inputMenu() Is similar to input Choice(), but privides a menu with numbered or lettered options.
                          inputDatetime() Ensures the user enters a date and time.
                          inputYesNo() Ensures the user enters a 'yes' or 'no' response
                              additional options for this input are yesVal="はい"  and noVal="いいえ" so you can change languages if needed.
                          inputBool()  Is similar to above, but takes a 'True' or 'False' response and returns a boolean value.
                          inputEmail() Ensures the user enters a valid email address.
                          inputFilepath() Ensures the user enters a valid file path and filename, and can optionally check that a file with
                              that name exists.
                          inputPassword()  Is like the built-in input(), but displays * characters as the user types so that passwords, or other
                              sensitive information aren't displayed on the screen.
                          inputCustom()  allows you to pass in your own function to be used as a part of validation. You would do this by writing
                              the code for your custom function elsewhere, and then passing the name of that function into inputCustom.
                              REMEMBER!  When passing a function ITSELF, you don't use () after it because you are not calling it.
                              The reason you would use inputCustom() at all instead of just using the custom function itself, is that you can easily
                              combine your custom function with the built-in options listed at the top, such as blank, limit, default, etc...
- working with files  =   Path() First of all, it helps to import the Path() function by adding  "from pathlib import Path" at the top.  This function is a
                              filepath helper that can put together a correctly formatted filepath, given some arguments, and (I think) it works for any
                              OS system (Win, Mac, Lin). USE THIS.  If you don't you'll have to manually put together the various filepath styles for different
                              OS, which would be a real pain.  This function returns a "path object" apparently, which as far as I can tell, is like a string.
                          / When you want to concatenate strings, you use +, but for Path objects, you use /  .    Then you can do stuff like....
                                  Path('spam') / 'bacon' / 'eggs'
                                  Path('spam') / Path('bacon/eggs')
                                  Path('spam') / Path('bacon', 'eggs')
                              All 3 of these would evaluate to the same thing:  'spam/bacon/eggs'   The only thing to remember when using / like this is
                              that one of the first two values must be a Path object, otherwise you'll get an error.
                          CWD (Current Working Directory) any filenames or filepaths used in your code are assumed to be in the CWD if they do not include
                              the root directory.
                          Path.cwd() will return the current working directory. Remember, in Linux, you won't see C: or D:, you'll just see a /.  The letters
                              are strictly a Windows thing, and this (Ubuntu) is running on Linux/Posix
                          Path.home()   All users on the computer have a home folder for storing their files, and you can see it with this method.
                              On Windows, home directories are under C:\users
                              On Mac, home directories are under /Users
                              On Linux, home directories are often under /home   <--- this checks out, that's what I see on Ubuntu.
                          Absolute vs. Relative Paths.    An absolute path always begins with the root folder.  A relative path starts from the cwd.
                          Path(some_path).is_absolute()  returns True or False depending on the format of the path.
                          If you want to turn a relative path into an absolute path, just the Path.cwd() method and the / concatenator like so...
                              Path.cwd() / Path('my/relative/path')
                          .  and   ..   folders.  These are special names for folders.  A single dot means "this folder", double-dots means "parent folder".
                              The single dot version is optional; if you just start with the folder and/or filename, it does the same thing.
                          os.makedirs()  and  os.chdir() are for making and changing directories, respectively. (Just an FYI for a shortcut, you can
                              just write out a long filepath that doesn't exist yet when using os.makedirs, and all the necessary intermediate folders
                              that would be needed to get to the final file/folder are also created along the way.)
                          Path(some_path).mkdir() will turn a path object into a directory.  NOTE THAT THIS IS NOT THE SAME AS os.makedirs() !!!
                          os.path.abspath(path) will return a string of the absolute path of the argument. It's an easy way to make a relative an absolute.
                          os.path.isabs(path) will return True if the arg is an absolute path.
                          os.path.relpath(path, start) will return a string of a relative path from the start path to path.  If start is not provided, cwd is used instead
                          os.unlink(path) will delete a single file at "path"
                          os.rmdir(path) will delete the folder at "path", but it must be empty of any files or folders to work.
                          os.walk(string folder path) is usually used in a for loop to "walk" through a directory: that is, visit every file and subfile in
                              a given directory.  On each pass through the loop, it returns 3 values:
                                  a string of the current folder's name
                                  a LIST of STRINGS of the folders in the current folder
                                  a LIST of STRINGS of the FILES in the current folder.
                                  ("current folder" in this case means the folder for the current iteration of the loop, not the cwd.)
                              You can choose a variable name for the 3 values listed, such as "foldername", "subfolders", and "filenames".  Here's how to use it.
                                  for folderName, subfolders, filenames in os.walk('some folder path'):
                                      print('The current folder is ' + folderName)
                                      for subfolder in subfolders:
                                          print('Subfolder of ' + folderName + ': ' + subfolder)
                                      for filename in filenames:
                                          print('File inside ' + folderName + ': ' + filename)
                              this method returns a LIST of STRINGS.
                          Getting PARTS of a filepath:  The parts of a file path include the following,
                              The 'anchor', which is the root folder (basically just a slash  /) (Windows systems have a 'drive' letter before the anchor slash)
                              The 'parent', which is the folder that contains the file
                              The 'name' of the file, which is made up of the...
                                  'stem' (what you named it) and the
                                  'suffix  (the .txt .mp3 etc part.)
                              Once you have stored a Path object in a variable, you can get these parts easily...  p = Path('C:/Users/JD/spam.txt')
                                  p.anchor      gives    C:\\
                                  p.parent      gives    C:/Users/Al  <--- a Path object is returned, not a string.  The others all return strings.
                                  p.parents[0]  gives    a Path object corresponding to the full path given.  for each index you go up, the path
                                                         goes up the chain one folder.  parents[1] is one folder up from parents[0], and so on.
                                  p.name        gives    spam.txt
                                  p.stem        gives    spam
                                  p.suffix      gives    .txt
                                  p.drive       gives    C:
                          Find File Size:   os.path.getsize(path) will return the size in bytes of the file in the argument.
                          Find File Names:  os.listdir(path) will return a list/array of filename strings for each file in the path argument ()
                          Glob Patterns:  WTF is this? Huh. Path objects have a .glob() method which is used to list the contents of a folder according to A
                              "glob pattern"....  riiiight.  Glob patterns like a simplified form of regex that are often used in command line commands.
                              This method returns a "generator object" (seriously, wtf?) that you have to pass to list() to easily view in iPython3.
                              Let's look at some examples to wrap our noggin' around this...
                                  p = Path('/home/akakemushi/desktop')   <-- or some path like that...
                                  p.glob('*')   -->  will return something like: <generator object Path.glob at hexidecimal_number_here>
                                  list(p.glob('*'))   -->  will make a list from the generator.
                                  [PosixPath(blablabla.png), PosixPath(blablabla.pdf), PosixPath(blablabla.jpg) etc etc...]
                              In the above, the asterix * stands for "multiple of any characters", so it returns all files in the path. However, you can
                              create complex glob patters just as you can with regex, such as
                                  list(p.glob('*.txt'))    <--- this will only return the .txt files in that path.
                              The question mark (?) stands for any SINGLE character.
                                  list(p.glob('project?.docx'))    <---- would pick up files like  "project3.docx", "projectA.docx" etc..
                              You can combine * and ? anyway you like, such as....
                                  list(p.glob('*.?x?'))  <--- would pick up .exe files as well as .txt files.
                          Path Validity:  use p.exists() to see if a path exists (True) or not (False)
                              use p.is_file() to see if something exists AND if it's a file or not. (False if not, or doesn't exist)
                              use p.is_dir() to do the opposite of the above.
                              You can check to see if a flash drive is plugged in with these:  dDrive = Path('D:/')  ->  dDrive.exists() -> False
                              (not sure what the Linux equivalent is.)
                          Read / Write:   We're mostly working with plaintext files in this book.  ALL OTHER FILES are known as BINARY files, which
                              a text editor cannot display as intelligible text.
                              plaintext files are basically just long strings.  That's all they are.  You can read from them with p.read_text(), and
                              write to them using p.write_text('string').   .write_text will create a new file, or overwrite an existing one.
                                  from pathlib import Path
                                  p = Path('spam.txt')
                                  p.write_text('Hello, world!')
                                  13   <--- this output is just the length of the string you wrote.
                                  p.read_text()
                                  'Hello, world!'
                              Note that these two methods are limited.  Usually you need to call open(Path object or string here) first to get back a
                              File object. The path passed to open() can be absolute OR relative. Then you call read() or write() on the File object,
                              (Note that these are NOT read_text/write_text, as above.)  and finally call close(File object) on the object.
                              Opening files in this way only opens them in "read mode" by default, so you CANNOT modify them.  To do that, you need
                              to pass a second argument to the open() function, a "w" for "(over)write mode", or an "a" for "append mode".  (You can technically
                              also pass "r" for read mode, but that's not really neccessary since it's the default.)  Note that the write() method
                              does NOT automatically add a new line at the end like print() does. You have to do that manually.
                              Here's an example of how you'd get the text out of a file:
                                  helloFile = open('blablablafilepath.txt', 'w')
                                  content = helloFile.read()   -->  now "content" contains the string that was read from the helloFile
                              Similar to the limited functions described earlier, trying to write or append to a file that doesn't exist will create a new file.
                              You can also read a plaintext file line by line, storing the strings as items in a list. the \n character is the delimiter.
                          Shelf Files:    These are files used for storing other kinds of variable values that are not strings/plaintext
                              To use these, first import the library "shelve".  Then call shelve.open() and pass it a filename, storing the returned
                              shelf value in a variable. You can make changes to the shelf value as if it were a dictionary.  When you're done, call close()
                              on the shelf value. So a shelf file, is basically a hash/dictionary, and as you know, the keys in a dictionary can hold any kinda
                              of data type that you need.  Here's an example:
                                  import shelve
                                  shelfFile = shelve.open('mydata')  <-- IMPORTANT DISTINCTION: while the open() function can take a Path object or a string, the shelve.open() method ONLY takes strings.
                                  cats = ['Mr. Bigglesworth', 'Mr. Munch', 'Felix']
                                  shelfFile['cats'] = cats    <--- creating a new key in the shelfFile called cats, and setting the value to the cats list.
                                  shelfFile.close()
                              Shelve files are always in "write mode".  There are no options to change it.
                          SHUTIL module:   This module has functions for copying, moving, renaming and deleting files.
                              shutil.copy(source, destination)   does what it sounds like.Both source and dest can be strings or path objects.
                                  if destination is a filename, it will be used as the new name of the copied file.  This function returns
                                  a string or Path object of the copied file.
                              shutil.copytree() will copy an entire folder and every folder and file in it.
                              shutil.copytree(source, destination) will copy the folder at the path (source), along with all its fules and subfolders,
                                  to the (destination).  In this case, both the source and destination args are strings.  This function returns
                                  a string of the path of the copied folder.
                              shutil.move(source, destination) will move the file or folder at "source" to the "destination".  It returns
                                  a string of the absolute path of the new location. A few notes about this to avoid bugs...
                                  - If destination points to a folder, the source file gets moved into destination and keeps its current filename.
                                  - If the given folder exists, the file is moved into that folder, and a previous file of the same name is overwritten.
                                  - You can add a new filename to the end of the destination to rename the new (moved) file.
                                  - If the given folder DOESNT exist, then the new file gets RENAMED to the name of that non-existant folder without
                                    a file extention (a hard to spot bug!)
                              shutil.rmtree(path) will remove the folder at path, and all contained subfiles and subfolders. (By contrast, os.unlink and
                                  os.rmdir mentioned above only remove a single file or empty folder.)
                                  BE CAREFUL WITH THIS AND .MOVE!!  a tiny typo in a file extension could accidentally delete important stuff!
                                  A safe practice is to comment out the part in the loop that actually does the deleting, and add a "print" line to
                                  make sure the function does what you think it does.
                          send2trash.send2trash(string path) is a 3rd party library that just sends files to the recycle bin rather than delete them.
                          zipfiles     there is a zipfile module that is simply called "zipfile".
                              this module gives you the ability to access new objects called ZipFile and ZipInfo (with those capital letters).
                              creating a ZipFile is similar to creating a File object, and a ZipFile object has its own set of methods. Make them like this
                                  p = Path.home()
                                  exampleZip = zipfile.ZipFile(p / 'example.zip')
                                  exampleZip.namelist()  <--- will output the names of all the files in the zipfile.
                                  spamInfo = exampleZip.getinfo('spam.txt')  <---- .getinfo creates a "ZipInfo" object about that file.
                                  spamInfo.file_size    <---- will output the filesize in bytes as an int.
                                  spamInfo.compress_size  <--- will output the filesize when compressed.
                                  exampleZip.close()
                              To extract zipfiles, call ZipFileObjectHere.extractall()   This will extract all files to the cwd.
                              To extract a single zipfile, call .extract(file name here)
                              You can optionally add a location where you want the file to be extracted to, if you don't want cwd.
                              To CREATE a zipfile, you must pass the name of the file, and a second argument 'w', to put it in write mode.
                                  You can then use zipFileName.write('addedfilename.txt', compress_type=zipfile.ZIP_DEFLATED)
                              To ADD things to a zipfile, you must open the file in "append" mode by using 'a' as the argument, just like with files.
- help                =   Now this is neat, you can use the built in help function in the console to learn the usage of a particular built-in or
                          imported function like so...     help(pyip.inputChoice)

STANDARD LIBRARIES    (Remember, you can use import library_name as shorthand_name to make calling the functions within easier)
Name        Description
random      contains functions related to random number generation, such as random.randint(1, 10), random.choice(list)
sys         contains functions related to the.. system? I guess? Such as sys.exit(), which will terminate the program immediately.
            (normally it terminates when it reaches the bottom.  This is useful for an infinitely looping menu that doesnt exit until the user
            selects or types "exit")
os          contains stuff like os.chdir for changing the current working directory, os.mkdirs for creating directories, and os.listdir()
            also contains os.path library, which has additional methods like os.path.abspath(), os.path.isabs(), os.path.getsize()
re          contains functions related to regex
math        contains functions related to math (duh).  such as round(float) and abs(int/float) which turns values positive.
time        contains functions for clocks and waiting, such as time.sleep(0.1)  (pause for 1/10 of a second)
copy        contains function for copying, useful for passing mutable data types such as lists and dictionaries.  Has .copy() and .deepcopy()
pprint      contains pprint and pformat, which help make output more readable (like printing hash data on separate lines, for example)
pyperclip   (3rd party, must download) contains functions for accessing your computers clipboard, which is handy!!
            namely,  pyperclip.copy() and pyperclip.paste()
pyinputplus (3rd party, must download) contains various data validation shortcuts so you don't have to write them yourself.
send2trash  (3rd party, must download) contains a safer, less "permanent" way to delete files than shutil.rmtree()
pathlib     has stuff related to filepaths, however in the book example, you don't import the whole thing.  You use the following line:
            from pathlib import Path      <---  this shortens what we need to type later.  We can just type "Path" instead of "pathlib.Path"
shelve      contains functions related to saving and opening files that are not just plaintext. If you want to "shelve" some variables for later.
shutil      contains functions for copying, moving, renaming and deleting files. (Short for "shell utilities")
zipfile     contains functions related to zipfiles and includes a data type called ZipFile, which has its own methods.
