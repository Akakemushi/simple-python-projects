For anyone reading this, these are just my personal notes as I get to know the Python language and how it is similar/different from Ruby/Javascript.

- Quick note about linux that I didn't know, folders and filenames are case sensitive in Linux.
- Another OS note, Windows uses backslashes to separate folders in a filepath, while Mac and Linux use forward slashes /.   huh. If you want your
  program to work on all systems, you'll have to handle both cases.
- pip is the package installer for Python. pip allows you to install additional Python libraries and packages from the Python Package Index (PyPI).
  It's useful for managing dependencies in Python projects. With pip, you can install packages like NumPy, Django, Flask, etc., by running commands
  such as       pip install package_name or  pip install --user package_name
- to run python programs, do   python3   followed by the filename in the command line
- the file extension for python is .py, and there is also .pyw, which won't show a terminal window when it runs.
- REPL  stands for  Read  Evaluate  Print  Loop,  and it's a way to execute python code typed into the console and get immediate results.
- To initiate REPL,   simply type   "python3"  with nothing after it in the console.  To exit,  either do ctrl + D  or type "exit()"
- BUT!  There is a BETTER version of REPL, which is running    "ipython3"  which gives you stuff like remembering previous commands, using tab, etc.
  Exiting ipython3 is the same as the previous.
- Python is NOT as smart as Ruby, and does not assume that a string + an integer = a string (implicitly converting the integer into a string for you.)
- the "+" operator works on strings for concatenation.
- the "*" operator works on strings for MULTIPLIED concatenation! Nifty.  "Bob" * 5  --> BobBobBobBobBob
- you can put as many * as you want in str * int expressions, and it doesnt matter if they're before or after the str (or both) however you can't
  mix different operators.  For example   10 // 2 * 1 * "Bob" will not work, as the // operator is present.
- python convention is to use underscores for variable names (but this textbook uses camelcase)
- you can do comparisons between ints and floats.   (eg.  14 == 14.00     would be true.)
- comparisons between strings and non-strings will always be False.
- ORDER OF OPERATIONS  1. Math (see syntax) and comparison operators evaluate. 2. "not" operators. 3. "and" operators.  4. "or" operators are last.
  2 + 2 == 4 and not 2 + 2 == 5 or 2 * 2 == 2 + 2
  2 + 2 == 4 and not 2 + 2 == 5 or 4 == 2 + 2
  4 == 4 and not 4 == 5 or 4 == 4
  True and not False or True
  True and True or True
  True or True
  True
- HOW BLOCKS OF CODE WORK IN PYTHON:
    Blocks begin when the indentation increases.
    Blocks can contain other blocks.
    Blocks end when the indentation decreases to zero or to a containing block's indentation.
    Example below:

    name = 'Mary'
    password = 'swordfish'
    if name == 'Mary':
      print('Hello, Mary')
        if password == 'swordfish':
          print('Access granted.')
        else:
          print('Wrong password.')
  Exceptions exist to this rule though, for example, you can have an array/list span across several lines, and Python is smart enough to know
  that the list is not done until it finds the closing bracket ]
  There is also an "override" method when you want to force a particularly long line of code to be on two lines for readability.  To do that,
  you can "pause" the line of code by ending the line with the backslash character   "\".  This tells Python that there is more to come on the next line.
- Libraries/modules are needed to access other functions in Python.  SEE LIBRARIES SECTION FOR LIST
  To include/access those functions in your program, you use the "import" keyword, the name of the module,
  and optionally, more module names separated by commas  DO NOT OVERWRITE MODULES BY GIVING YOUR FILES THE SAME NAME!!
  On that note, You CAN make your own modules (which is just a fancy word for another .py file you've saved in the repository or on your PATH somewhere)
  which is really useful for making little methods/functions that you want to reuse and import elsewhere.  For an example of this, look at the file
  "readDocx.py".  I made this, and I can import it and use the function defined within with   readDocx.getText(filename)   Pretty sweet!
- Keyword Arguments  ---  What is it?  Most arguments are identified by their POSITION in the parentheses, but keyword arguments are called by name
  right before the argument passed to them, like so...  print("Hello", end="")    <-- here "end" is an optional parameter being filled in. (If you careful
  to know, it declares what the final character(s) will be, replacing the default new line character. Another you could use with print() is the "sep" argument
  which replaces the default space with something else when multiple strings are given to print.
- Threads and Threading.  By default, Python programs have a single thread of execution. I'm pretty ok with this concept already, but just in case,
  The idea is that if you imagine placing your finger on a flowchart for a program, your finger can never be in more than one place at a time.  If
  you used more fingers, you could activate different parts of the program at a time, which is what multi-threading is.  Doing this allows you to
  have one thread stop and wait, or perhaps handle some task that takes a while, while another thread is doing other things at the same time.
- Python Call stack is FILO, First in, Last out.  If a function calls another function, that second function is completed and returns before the first
  function can continue.  Pretty standard.  Terminology wise, when a new function is called, a "Frame Object" is added to the top of the stack.
- !!SCOPE!!   Variables that are assigned within a function call are in the "local" scope, while variables assigned OUTSIDE of any function are in the "global".
  A variable must be in one or the other, it cannot be in both.  THIS IS IMPORTANT!  Local code can READ global variables, but it cannot CHANGE/OVERWRITE
  global variables!  This means that it's technically okay to have a global and a local variable with the same name, as they won't interfere with one another.
  Finally, if you declare a local variable with the same name as a global, the local code will prioritize the local value over the global one, but if a
  variable name is used that has not yet been created locally, the function will assume its a global that you're talking about.
  Note: If you try to READ from the global version, then DECLARE the local version afterwards, you will get an error.  You can't do that.  It really is
  global or local ONLY. Not both.  There IS a way to modify global variable from the local scope, with the "global" keyword (explained later)
  BEST PRACTICE:  Even though you technically CAN use variables with the same name... don't.  It can get confusing which variable is being referenced.
  I don't think that's the case in Ruby... I think local code CAN overwrite globals.
- FORCING a GLOBAL   In regards to scope above, if you MUST alter a global variable from within a local scope, you can do so by invoking the "global" keyword.
  At the top of the function,   use the keyword "global" followed by the name of the global variable.   This sort of "imports" the actual global variable
  into the local scope, and from there, you can set its value to something else as normal.  Doing this will NOT create a local variable with that name.
- SEQUENCE DATA TYPES  Python has a few different sequence data types, which are lists, strings, range objects returned by range(), and tuples.  Many of The
  things you can do with lists can also be done with strings and other values of sequence types: indexing, slicing, using them with for loops, with len(),
  and with the in and not in operators.
- MUTABLE and IMMUTABLE DATA TYPES  Mutable things like lists can have values added, removed or changed.  These terms are important for the definition of
  "mutated", as "overwriting" means that the original is completely thrown out, and something entirely new replaces it.  Strings in Python are Immutable.
  That means that while you can READ specific parts of a string using indicies and slices, you cannot reassign just a part of the string... you have to
  reassign the whole thing.   name = "Jason"    name[2] = "x"   will NOT work.  You would need to do some splitting and concatenation for that, invoking
  new / temporary variables.  This will become important when dealing with "Passing References". In short, there are MUTABLE and IMMUTABLE areas in CPU memory.
- TUPLES  wft is a tuple?  Well it's basically the "IMMUTABLE" clone of the LIST data type.  They are created just like arrays, but with parentheses instead
  of square brackets.  greetings = ("sup", "hi", 3.5, -9).  You can read indexes and slices from tuples, just like lists, but you can't overwrite
  single indexes like you can with lists.    greeting[0] = "bro" will NOT work.     Also, if you need to create a tuple that only has one value in it,
  you'll need to follow that value with a comma, otherwise, Python will think you're just declaring a simple str, int, or float that happens to be inside
  some parentheses.  It has no way to distinguish parentheses used in math from tuple parentheses unless there's a comma inside.
  names = ("Jason",)  is a tuple,   names = ("Jason") is a string.   So why use these? Well, Python can implement some optimizations that make code using
  tuples slightly faster than code using lists.   It also indicates to others some sequential data that you don't intend to change.
- MEMORY IN PYTHON   Variables just store a reference to some value in memory, so when you make another variable reference a previous variable, you're
  actually assigning it the reference to that data, not the data itself.  So if later on you go and change what the first variable is set to, the first
  variable and the second variable will now be pointing to different places in memory.  Let me show you.
    spam = 42      spam points to where 42 is located in memory.
    cheese = spam       cheese points to where spam is CURRENTLY pointing to in memory, so 42.
    spam = 100     spam is now pointing to somewhere else in memory, where 100 is.  But cheese is still pointing to 42.
    spam   (outputs  100)
    cheese  (outputs   42)
  Interestingly enough, I tested this out in Ruby, and Ruby does the same thing, which I didn't know.
  What this means is that when spam was reassigned to 100 above, it did not "change" 42 into 100.  It opened up a new spot in memory, put 100 inside it,
  and referenced that instead.  The spot where 42 resides was left untouched.  Now, MUTABLE data DOES change that exact spot in memory, so anything else
  that references that spot will also "see" the change.  To play around with this, you can get the memory address of some value by
  doing id(variable or value here), and you'll get some arbitrary string of numbers representing the address (which will vary). Check this test out...
    In [2]: num = 12
    In [3]: id(num)
    Out[3]: 140228057547344
    In [4]: num2 = num
    In [5]: id(num2)
    Out[5]: 140228057547344     <--- num2's address is the same as num's
    In [6]: num = 42
    In [7]: id(num)
    Out[7]: 140228057548304     <---- num's addres changed...
    In [8]: id(num2)
    Out[8]: 140228057547344     <---- but num2's did not.
- PASSING LISTS/REFERENCES AS ARGUMENTS     This is an important concept to grasp in order to avoid difficult bugs dealing with memory and pointers.  So,
    when passing IMMUTABLE data types into functions/methods, you're usually fine because copies are made locally, which will not affect the global versions.
    However, when passing MUTABLE data types like lists, you're passing in the reference to the original value, and therefore any changes you make to
    that array locally, WILL CHANGE the original as well, since its referencing the same place in memory.  If you don't want that to happen, you have two
    choices: either convert the data to a type that is immutable (such as from list to tuple), or import the copy library and use copy.copy(list) to make
    a second list that you can safely manipulate without affecting the other one. (and if it's a list of lists, use copy.deepcopy(list) instead.)
- WRAPAROUND HACK (not really a python-specific thing, but I thought it was cool math hack.)  You can use the modulus operator (%) to get the value on the other
    side of an array or matrix.  Let's say you have an array of some length, say, 10.  Now let's say I want to find the values of indicies ADJACENT TO some
    specific index.   Well, if I'm at index 3, then I can find the adjacent ones by going to indicies i+1 and i-1, right?  But what if I'm at the start or
    end of the array?  If i = 0, what then?  I can find i + 1, but there's nothing at i - 1...  Well, we can "wrap around" to the end of the array (that is
    to say index 9) by using  (i - 1) % length.  I don't fully understand why, but when a negative number enters the equasion, the maximum the remainder can
    be becomes the divisor instead of the dividend.  Normally, (when working with positives), the remainder is how much of the dividend was left over when
    as much of it was divided as possible using the divisor.  So for 15 drinks / 6 people, we think of it as 15 drinks - 6 drinks = 9,  9 - 6 = 3, and we can't subtract/reduce
    give the remaining 3 away because everyone wouldn't get one because we don't have enough, so 3 is the remainder of 15, the dividend.  Likewise,
    if we try doing 4 / 10, we think of that as 4 - 10,     which is impossible right off the bat, leaving a remainder of 4.
    Again, it's the dividend.  When you throw a negative number in the mix though, things change.
    -1 % 10 for example leaves a remainder of 9, which is much larger than the dividend, but fits within the divisor. -11 % 10 and
    -101 % 10 also have a remainder of 9.  So while I don't quite understand why, it seems like you can essentially just take the remainder of the divisor?
      -1 % 10 = 9
    is functionally equivalent to...
      I have a -1 cubic foot hole to fill.  I have buckets which cointain 10 cubic ft of cement each.  When the hole is full, how much is left in
      the final bucket?  The answer would be 9 cubic feet. If it was -101 cubic feet, I would use 10 buckets, and 1 cubic foot from the final bucket,
      still leaving 9.
    all this is to say, this method works with all the other indicies, too.    i = 5? No problem.  (5 - 1) = 4  -->    4 / 10 would leave a remainder of 4.
- Chaining method calls.   You can chain method calls in Python just like in Ruby.  Something like myString.upper().lower() is valid.
- You can set "constants" in Python by declaring them in ALL_CAPS.

SYNTAX NOTES
- Strings               Assignment is just like Ruby, use single or double quotes, with double quotes for using single quotes inside.
                        Escape character--   is the backslash character \.  use these
                            \' single quotes
                            \" double quotes
                            \t  tab
                            \n  newline
                            \\  backslash
                        Raw String-- You can convert a string to a "raw string" by puting an r before the initial quote.  Doing so will ignore all escape characters
                          and print exactly what you see. These are helpful if you want to type something that has a lot of backslashes such as a filepath
                          or perhaps url.
                        Multiline strings-- can be started with triple single quotes '''   ''' .  If you do this, you dont need to manually enter \n characters.
                          Multiline strings also accept both single and double quotes by default.  (Note that multiline comments follow a similar formula
                          using three double quotes """   """).
                        String slices-- can be taken just like arrays (below)  myString[3:7] myString[4:]   myString[:9]  etc.
                        String search-- can be done using   search_term in myString  or  search_term not in myString, just like arrays.
                        String interpolation--  There are TWO WAYS to do it in Python now, as of 3.6.  The first is the old way, which looks like this..
                          "This is the old style previous to %s %s." % ("coding_language", version_number)
                            In this version the %s converts whatever data type is sent to it into a string automatically, so you dont need to call str().
                          f"This is the new style of interpolation as of {coding_language} {verson_number}"
                            This is an f-string, and like raw-strings, you MUST HAVE the letter "f" written just before the initial quote mark.
                            as with #{variable} in Ruby, you can do operations and stuff within the {}.  Also, anything within the {} is converted to str.
                        String case--  myString.upper() and myString.lower() convert ALL the characters in the string to upper or lower. These methods do not
                          modify the original string: they return a new one, so you need to store it or set the original equal to the new one.
                          Two other relevant methods are   .islower() and .isupper()  which return T/F if the string is ALL upper or ALL lower.
                          Note, however that there MUST be at least one alphabet character within the string for this to return True. "12345".islower() will be False.
                        isX() methods-- These are various Boolean tests that look at the string and tell you if it matches a particular format.
                            isalpha()   Returns True if the string consists only of letters and isn't blank.
                            isalnum()   Returns True if the string consists only of letters and numbers and is not blank.
                            isdecimal() Returns True if the string consists only of numeric characters and is not blank.
                                        total misnomer here... only returns true if it's a positive whole number or 0.  "3.14" would be False.
                            isspace()   Returns True if the string consists only of spaces, tabs, and newlines and is not blank.
                            istitle()   Returns True if the string consists only of words that begin with an uppercase letter followed by only lowercase letters.
                                        note that this is sort of a misnomer.  Titles don't capitalize prepositions, but this method thinks they should be.
                        startswith()    takes a string as an argument and returns true or false depending on if the beginning of the string matches the argument.
                        endswith()      same, but matches the end of the string.   These two are useful alternatives to the == operator if you dont need to compare
                                        the entire string.
                        join()      !!! Ruby is different !!! If you have a list (array) of strings that need to be joined together.
                                    In Ruby, this is an array method...   myArray.join(" "), but in Python, this is a STRING method, so the syntax is reversed...
                                    " ".join(myArray)   This would be easy to overlook, so WATCH OUT
                        split()     This is the same as Ruby.  myString.split("some_delimiter") will output a list/array.  If left blank, the default is whitespace.
                                    You can use it to split text by newline characters.
                        partition()     This is new to me.  It takes a string argument to be used like a delimiter, but what it returns is not like .split.
                                        It returns a TUPLE with 3 parts, the first is the "before the partition", the second is the partition itself, and the
                                        third is "after the partition".  It will never return more than 3 parts, even if more than one instance of the partition
                                        is found in the string.  It will use the first one and ignore the rest.  It's a little weird, so as an example,
                                        "I am the king of France".partition("the") would return a tuple containing (("I am ", "the", "king of France"))
                                        Also, if the partition string does not occur in the string, then the first part of the tuple will be the whole string,
                                        and the other two will be blank.  I can't think of a reason to use this, but if you need to keep the partition itself
                                        for some reason, I guess this could be useful?
                                        You can use the multiple assignment trick to catch all three parts into variables like so...
                                        before, partition, after = "This is a test".partition("is")
                        justify methods ---   There are 3 methods that can be used to justify the console output of Python.
                            rjust()     Justify right.  Takes an integer argument that represents the TOTAL WIDTH of the output in the console,
                                        then adds spaces to the left of the string its called on until that total width is reached.  So, if you did, say...
                                        "Hello".rjust(20),    you would get and output of "               Hello", that is, 15 spaces + 5 characters to make 20.
                            ljust()     Justify left.  Same as above, but left.  Duh.
                            center()    Justify center.  You guessed it.
                            Note that you technically CAN put a value that is less than the string length, but no spaces will be added, so it's pointless.
                            Note also that you can add a second argument to change the default (spaces) to some other string or character. center(20, "*") for example.
                        strip methods  --- Used when you want to remove the whitespace from a string (space, tab, newline).
                            strip()     This exists in Ruby, too.  It just returns a string that has all the leading and trailing whitespace removed.
                            rstrip()    Removes whitespace on the right side.
                            lstrip()    Removes whitespace on the left side.
                            Optionally, you can add a string argument into any of these methods.  By doing so, you'll strip away ANY CONSECUTIVE OCCURANCES of ANY
                            of those characters, regardless of order.  Eg., strip("dog") would strip away any lowercase "d", "o", or "g", it found as follows...
                            "odododgggCATgodgod".strip("dog")   outputs  -->    "CAT"    and
                            "ododRodgggCATgodgod".strip("dog")   outputs  -->   RodgggCAT  because that capital R breaks the consecutive string.
                        Unicode stuff  ---  when you need to get the unicode value of a character, or convert a unicode value into a character.
                            ord()       Takes a single-character string as an argument, and outputs the unicode point value of that character.
                                        Note that this is NOT a string method, it is a built-in Python function.
                            chr()       Opposite effect--  takes an integer representing the unicode value of some character, and outputs that character.
                            You might use these when you need to do math on letters... or order them... or something.... I dunno.
- Regex stuff           all regex patterns and functions are included in the "re" library, so you need to import that.
                        there is a free online regex tester for python at  https://pythex.org
              .compile  to make a regex object, call re.compile() on a string representing the regex.  You can catch the returned object in a variable
                            phoneNumRegex = re.compile(r'\d\d\d-\d\d\d-\d\d\d\d')   the "r" at the front means "raw string", and is used to ignore the escape characters.
                            there is an optional second argument you can pass to .compile after the regex...
                                add re.DOTALL (without quotes) to make the dot character also include newlines in its matches.
                                add re.I or re.IGNORECASE to make the search case insensitive.
                                add re.VERBOSE to make the regex ignore whitespace and comments inside the expression, which frees you up to spread a particularly long
                                  and complicated regex over multiple lines and comment on what each part of the regex does. USE TRIPLE QUOTES FOR THIS ''' '''
                                if for some reason you wanted to use 2 or even all 3 of these options, you can, but since the .compile method only accepts 2 arguments,
                                  you have to "trick the system" a bit, by separating the options with a pipe..   re.compile("string", re.I | re.DOTALL | re.VERBOSE)
              .search   to use a regex, call myRegexObject.search('This is a string you want to search through.").  You can catch the retuned "match object".
                        NOTE: the .search method only returns the FIRST match found, and ignores any other matches.
                            mo = phoneNumRegex.search('My number is 415-555-4242.')   (mo is shorthand for "match object")
              .findall  this is like search, but returns EITHER: a list of matches as STRINGS, OR: a list of TUPLES of strings if there are groups used in the regex pattern
              .sub      this is a substitution method for a regex object.  It takes two arguments, the first is the string you want to INSERT INSTEAD,
                        and the second is the string that you are going to run the find and replace on.  The search term itself is already in the regex object.
                        If you want to include the "found match" in the replacement, you can do that by putting the part of the match you want to include in a group.
                        Once you do, you can then refer to that bit of the match using \1, \2, \3, etc within the replacement string. It's a tad hard, so here's an example
                              agentNamesRegex = re.compile(r'Agent (\w)\w*')    <--- the regex looks for stuff like "Agent Jane"  'Agent Thomas", etc... and "captures"
                              the first letter of the name in the inner parentheses you see above (\w).  This letter can now be refered to by using \1
                              agentNamesRegex.sub(r'\1****', 'Agent Alice told Agent Carol that Agent Eve Knew Agent Bob was a double agent.')
                              this will output the first letter, followed by 4 asterix in any place where "Agent Something" occurs.
                              A**** told C**** that E**** knew B**** was a doulbe agent.
              .group    to view the contents of a match object, call myMatchObject.group() to get a string containing just the match. (Without using .group(),
                            what you will get is the match plus some other data about that match, like where it was found.)  if you have created multiple
                            groups with additional ( ) in your regex, you can use the plural form .groups() to see them all in a tuple.
                        - \ the escape character, needed if you want to match any of the following   .  ^  $  *  +  ?  {}  []  \  |  ()
                            I think this is kinda weird, since we're using r'regexhere' to get a raw string... so I thought that all the \ characters
                            would be ignored... My best guess as to why this works is because of the .compile method you have to use.  Maybe we need
                            to send a raw string to the compile method, and the compile method has its own way of escaping things??  I dunno.
                        - ( )  creates a group for using the .group method later on.  eg.  (r'(\d\d\d)-(\d\d\d-\d\d\d\d)')
                            with this pattern, you could later do mo.group(1) to get just the area code, or mo.group(2) to get just the local number.
                        - \d   matches a single digit, 0-9
                        - \D   matches any character that is NOT a numeric digit 0-9
                        - \w   matches any letter, numeric digit, or the underscore character, so a-zA-Z0-9_
                        - \W   matches any character that is NOT the above /w
                        - \s   matches any space, tab, or newline character (so whitespace)
                        - \S   matches any NON-whitespace character.  this is kinda like \w, but it would also include special characters like $#& etc.
                        - {3}  matches the pattern (or character) preceeding it exactly x number of times.  \d{3} is equivalent to \d\d\d
                              you can also specify a minimum, maximum or both number of times by including a comma.  {3,5}, {,5}, {3,}
                        - |    The pipe is basically like "or".  It will return the FIRST match it finds from either side of the pipe. Can be used in a group, too.
                              (r'Batman|Tina Fey')       (r'Bat(man|mobile|copter|bat)')  <-- would match Batman, Batmobile, Batcopter, and Batbat.
                        - ?    Question marks mean that the preceeding group/character is optional (0 or 1 instances).  (r'Bat(wo)?man') matches both Batman and Batwoman
                               HOWEVER!!  There is a SECOND use for question marks; when they follow a range, like {3,5}?  By using a ? after a range, it tells the regex
                               to be LAZY and not GREEDY.  (Greedy is the default behavior).  It will then match the shortest possible string.
                        - *    The asterix means "match 0 or more" (r'Bat(wo)*man')  could match  Batwowowowowoman
                        - +    The plus means "match 1 or more"  (r'Bat(wo)+man')  would match Batwowowowowoman, but NOT match Batman.
                        - []   square brackets are for character classes. [a-zA-Z]  or [0-5] for example.  They are customizable versions of stuff like \d or \w
                               Note that inside the char class, the normal regex symbols don't function as such, and you do not need to escape them, like \$
                               The exception being the hyphen, which works to set a range. If you want to SEARCH for a hyphen in a char class, put it as the first
                               character (maybe last as well?) in the class, so that it isn't between two other characters.
                        - ^    Carrats have TWO uses
                               1). a character class starting with a carrat is a NEGATIVE class, so it matches any character NOT in the class,
                               just like the capital classes \D \W and \S
                               2). a regex that starts with a carrat means that the regex must be at the START of the string for it to count.
                        - $    dollar signs work like the second use of carrats (above), except that the regex must be at the END of the string to count.
                               That means that if you use both a carrat and a dollar sign, the whole string must match the regex, and have nothing else.
                        - .    period is the wildcard.  Matches everything except for newline.
                               use  .* for a greedy match all, and .*? for a lazy match all.  Here's the difference... "<I love melons> in bed>"
                                    (r'<.*?>') would find  "<I love melons>" and then give up.
                                    (r'<.*>')  would look through everything, and find '<I love melons> in bed>' as the longest match
- printscreen =         print("")  single quotes also work.   integers without any quotes also work.
                        You can pass multiple strings to print(), separated by commas, and they will be printed, separated by a space.
                        You can override the default spaces and new line characters that the print() function adds by using the Keyword Arguments "sep" and "end"
                        respectively, like so....    print("Hello", end="")  <-- stops console from going to next line.   print("milk", "eggs", "spam", sep=", ")
                        will change   the output    "milk eggs spam"  into   "milk, eggs, spam"
- interpolation =       To do interpolation, use the symbols %s, %i, or %f directly within the string-- then, after the final quotation mark (but still within
                        the parentheses), type a   %    followed by ANOTHER set of parentheses within the first set of parentheses.
                        Inside of the secondary parentheses you should include (in order) the values that will be filled into the string.
                        The values provided as arguments can be either direct values (such as, 6,  3.14,  or "giraffe") or variable names.
- concatenation =       nothing new here.  Just use ' + ' between two strings.   "I am " + "Jason"
- operators =           same as usual, but there is ORDER OF OPERATION in python, and priority is as follows from top to bottom...
                            ( ) parentheses.  Things inside of parentheses are evaluated first.
                            **  exponent
                            %  modulus (aka remainder)
                            //  Integer division/floored quotient  (it's just division, but it drops the remainder, if one exists (aka rounds down))
                            /   division
                            *   multiplication (works on strings and arrays too)
                            -   subtraction
                            +   addition (also concatenation for strings and arrays)
                        SO  as an example,  7 - 3 ** 2  evaluates to -2, not 16, because the exponent is evaluated FIRST.
                        You can also STACK exponents, so 2 ** 2 ** 4  evaluates to 65536 (huge), not 256.  The last exponent is evaluated and THEN the result is
                        treated as the exponent to the next exponent.   There are also shortcuts, as with other languages, as follows:
                            += x  the  shorthand  for   num = num + x      (also works on strings!)
                            -= x
                            *= x      (also works on strings!)
                            /= x
                            %= x
                        round(some_float) will round a float into an int, and round(some_float, number of decimal places) will round a float into
                            a shorter float.
- variables =           works like Ruby.  Just put the variable name = value.  You don't need to specify data type.  n = 3, name = "Bob"
                        naming restrictions.  1. alphanumeric and underscore only.  2. must not start with number 3. no spaces.
                        variable names are CaSe SeNsItIvE
                        you can delete a variable (and its value) using the keyword "del".  del variable_name (though there's rarely a need for this.)
                        There is a shortcut for assigning multiple variables at once, if you have an array(list) for them.  Basically, instead of this...
                            cat = ["fat", "gray", "loud"]
                            size = cat[0]
                            color = cat[1]
                            disposition = cat[2]
                        you could write this in 2 lines of code instead...
                            cat = ["fat", "gray", "loud"]
                            size, color, disposition = cat
                        Naturally, the order matters, and the number of variables MUST equal the number of list items.

- user input =          input()     you can add a message or question inside the parenthesis  input("What's your name?")
                        !!IMPORTANT!!   Input will ALWAYS be a string.  Also!!  This function effectively PAUSES your code until the user presses
                        the ENTER key... any other key will just type on the command line and will not progress the code.  You can sort of use this
                        to make the code "wait" until the user pushes enter.  See the stopwatch.py program as a good example of this.
- string length =       len(var)   or   len("String literal")
- array length  =       len(array)   or    len([2, 3, 4, 5])
- arrays         =      arrays in Python are called "lists", and the array itself is the "list value", which can be confusing.
                        So for example   pets = ["dog", "cat", "sloth"]     the "list value" would be ["dog", "cat", "sloth"], since that is
                        the value of "pets".    Stuff inside the array are called "items", and they are separated by commas, as normal.
                        You can make a list of lists  [[1, 2, 3], ["dog", "cat", "hat"]].
                        Lists CAN contain items of different data types, so   list = ["apple", 3, 5.7] is fine.
                        Like Ruby, you can get the LAST item by doing   list[-1]  and so on going backwards.
                        You can concatenate and multiply lists just like you can with strings using + and *
                        Error alert!  If you try to make a copy of an array by simply doing array2 = array1, it will NOT work.  Array2 will point to the
                        same array in memory.  To make a shallow copy, you can either do  arry2 = array1[:] or make use of the copy() module (see later)
- array slice        =  To get an array slice, the syntax is  array[1:5]   where the first is the start of the slice, and the second is the stop.
                        CAREFUL!  The second number means "go up to but NOT include this" Also, don't get confused and think that the second number
                        means the length of the slice... it doesn't.  You can set variable values with slices.  slice =  array[3:5]
                        Shortcuts -   by leaving out a number such as  [:5]  or  [3:]  you are telling Python that you want to start at the
                        beginning, or go all the way to the end, respectively.  You can also set the end of a slice to beyond the actual end of the list
                        and it won't error.  This is because you're not actually LOOKING at or ACCESSing what is there (or not there)
- array item removal =  To delete a single item from an array, use the keyword  "del", followed by the index like so:   del  array[2]
                        all the items after that index get moved forward. You can also delete using slice notation (see above)
- array include?     =  Works like a boolean operator such as == or > .  use keywords "in" and "not in" like so:
                        "howdy" in ["hello", "hi", "howdy", "heyas"]    <-- this would evaluate to True.
- array iteration   =   I over an array with a for loop, like so:   for your_variable_name in name_of_array:  this is for_each in Ruby.
- each_with_index   =   In Python you can do something like.....  for i in range(len(array)):    and use "i" for the index number and data.
                        Alternatively, you can use the "enumerate() function like so:
                            for index, item in enumerate(array_name):
                              print("Index ") + str(index) + " in this list is: " + item
                        Note here that the words "index" and "item" have been used, but you could use any variable name.
- tuples            =   tuples are created just like lists/arrays, but with parentheses instead of square brackets. ("hi", "hello", "sup")
                        tuples can be added together with +, so ("a", "b") + ("c", "d")  will give you ("a", "b", "c", "d").  If the tuples are each in
                        their own array, then [("a", "b")] + [("c", "d")], will give you [("a", "b"), ("c", "d")]
- sets              =   sets are created either by calling the set(somearray) method on some data, or by using curly brackets WITHOUT any colons
                          if you use colons, it becomes a dictionary/hash.  What is a "set"?  It is a special datatype, kind of like a list, BUT...
                              - A set will ignore any values added to it that already exist. Every item is UNIQUE.
                              - A set has NO ORDER, and you cannot go to a particular index of a set.
                              - A set itself is mutable, BUT the items within it must be immutable, so you can't store dicts and lists in one (though tuples are ok)
                              - A set has a bunch of unique and useful methods built into it that help you find unique items
                                  - mySet.add(item)  adds the item to the set. (note this is not .append)
                                  - mySet.remove(item)  removes the item but THROWS ERROR if item doesn't exist.
                                  - mySet.discard(item)  removes the items, does nothing if not found.
                                  - if item in mySet   returns boolean T/F and is way more efficient than checking through an array.
                                  - (mySet1 | mySet2)  returns one set made from the items in both sets, WITHOUT any duplicates.
                                  - (mySet1 & mySet2)  returns one set consiting of only the values found that exist in both.
                                  - (mySet1 - mySet2)  returns the first set with any values that appear in the second set removed from it.
                                  - (mySet1 ^ mySet2)  returns the values that appear in one or the other, but NOT both.
- hashes            =   in Python, hashes are called "DICTIONARIES", but function exactly the same way...
                        myDictionary = {'key1': 'value1', 'key2': 'value2'}
- accessing hashes  =   Again, same as Ruby.  myDictionary["someKey"]  will give you the value stored at that key, and like Ruby,
                        the key-value pairs are unordered, so two dictionaries with the same key-value pairs are equal to each other regardless of order.
                        You can use integers and floats as the keys for hash values.
- hash sub-types    =   Dictionaries (hashes) in python have subtypes for all the keys, all the values, and all the key-value pairs.  To get these
                        data types (known as dict_keys, dict_values, dict_items respectively), use the name of the dictionary  followed by
                        .keys(), .values(), or .(items) respectively.  What you get back is not an array (it is not mutable like an array),
                        but something more like it, and you can ITERATE over it like an array, which is what they are usually used for.
                        If you want to turn these 3 data types into an array, you can:  just do  list(name_of_dict_type), as you would for a tuple.
                        It should also be noted that the dict_items  type contains a sequence of tuples.
                        IMPORTANT NOTE* If you iterate over a hash that has two or more keys named the same, only the LAST one will be counted, and only
                        the LAST value will be assigned to that key.  So, myHash = {"name": "Bob", "name": "Jim"} will be length 1, and name = Jim.
- check for keys/values  =   In ruby, this would be   hash.has_key?(search_term), but in Python, this would be search_term in dictionary.keys()  ,
                        making use of the "in" or "not in" keywords.  There is also a shortcut for this, if you just omit the final   .keys() it does the same.
                        You can likewise use .values() to search for a value instead.  (There is no shortcut for values.)
- get hash values      =   This combines checking for the existance of a key AND fetching the value all in one.     Do   dictionary.get(key, fallback)
                          As the syntax implies, you need two arguments, the first is the key whose value you want, and the second is the default or
                          fallback value to use in the event that the key doesn't exist.
- set key-value default =  The syntax for this is    dictionary.setdefault("key", "default_value")    What this does is check that dictionary for that key,
                           and if the key doesn't exist, it creates it and sets its value to the default value.  However if the key DOES exist already,
                           it simply returns the value that's already stored (thus ignoring the second argument).  This could be useful when you want
                           to keep a running tally of various items, but you aren't sure just how many different items there are.  You can dynamically
                           do this with something like...
                           tally_keeper = {}
                              for thing in group:
                                tally_keeper.setdefault(thing, 0)   <-- if the thing has never before been seen in the group, it adds it and sets it to 0
                                tally_keeper[thing] += 1    <--  It increases the count of that thing by 1.
- PRETTY printing       =  (must import pprint library)  the pprint.pprint(data) function is just a more readable way to print hash data.  Prints each
                           key-value on a new line. If you want that output returned as a string instead, use pprint.pformat(data).
- string/float to int  =   int(string/float)        (in Ruby it's     .to_i)   NOTE: making a float an int will always round it down.
- int/float to string  =   str(int/float)               (in Ruby it's     .to_s)
- string/int to float  =   float(int/string)           (in Ruby it's    .to_f)   NOTE:  making an int a float will add a .0 at the end.
- string/tuple to list =   list(str/tuple)         (in Ruby it's   .to_a)
- list/string to tuple =   tuple(str/list)      (not in Ruby)
                         CAUTION!  Note that the above 5 type converters ONLY MAKE COPIES; you need to catch the return value in a variable.
- comments           =   Use a hashtag to denote comments in python     #  this is a comments
- rounding numbers  =    round(float)  rounds to closest integer.
- absolute value    =    abs(int or float)  will turn the number positive if it is negative.
- data type check   =    type(variable_name or value)
- booleans        =      assign with True    or   False.  fisrt letter MUST be capitalized, and you cannot use True  or  False as a variable name.
- comparisons     =      exactly the same as Ruby, Javascript, etc.     ==  !=   <    >   <=    >=
- &&              =      keyword   "and"
- ||              =      keyword   "or"
- !               =      keyword   "not"    not True    will evaluate to False.   not not not not True    will evaluate to True.
- conditionals    =      the condition followed by a COLON... (not curly brackets or parentheses)      if 5 > 4:    if "andy" == "tom":   else:
- if statements   =      Python uses  "if condition:"   "elif condition:"  and   "else:"
- while statements =     Use   "while condition:"
- break statement  =     just type the keyword  "break"  with nothing after it to exit a loop prematurely.
- (NEW!) continue  =     just type the keyword  "continue" with nothing after it.   What this does is jump to the START of the while loop prematurely.
- Falsey values    =     0  (an int)  0.0  (a float)  and  ''   (an empty string)   all evaluate to False in Python.
- For  loop        =     Example-     for i in range(5):          the part  "in range(5)"  is unique.   It sets the falue of i to 0 initially,
                         then counts 5 times, so i will equal    i = 0,  i = 1, i = 2, i = 3, i = 4   stop.
                         Note:  The "continue" statement in a For loop will ITERATE and then jump to the start.
                         Also, be careful... the variable name you give the incrementor (such as "i") is apparently VISIBLE to code OUTSIDE of that loop!
- More about range()  =  The range() function can have 1, 2, or 3 arguments.  If it has only 1 argument, then the range is assumed to start at 0, and
                         stops just before the argument given.  If TWO arguments are given, then the first argument becomes the STARTING point, and that
                         is used instead of 0.  If THREE arguments are used, the third argument is the "step" setting, or maybe think of it as the interval.
                         It's the number of steps that the iteration skips over.  Examples:
                         range(11) produces 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
                         range(5, 11) produces  5, 6, 7, 8, 9, 10   <---Note that it produces 5, but not 10.
                         range(5, 0, -1) produces 5, 4, 3, 2, 1  <--- note that the only way you can "count backwards" is by including a negative step.
                         range(5, 11, 2)  produces  5, 7, 9  <-----Note that "10" is not produced because the last "skip" would skip past the end.
                         This function is for int  only, it will not work with floats.  You can, however, use negative numbers, and even count backwards.
                         SEE ALSO the module "itertools" for even more functions, like getting "chunks" from lists.
- random number          (must import random library) random.randint(start, end)  The arguments are inclusive, so the start and end numbers can appear as results.
- random array item      (must import random library) random.choice(array_name)
- shuffle array          (must import random library) random.shuffle(array_name) this shuffles the ORIGINAL array.  It doesn't make a copy.
- wait()                 (must import time library)  time.sleep(time in seconds)  argument is a float that represents seconds.
- copy()                 (must import copy library) makes a copy of a mutable data type.  The "why?" is more important than the "what" here. Info above.
- deepcopy()             (must import copy library) same as above, but works on lists with lists in them. (i.e., goes deeper, hence the name.)
- copy()                 (must import pyperclip library)  NOT THE SAME AS ABOVE!!!  This one accesses the computers clipboard.
- functions              =  use the "def" keyword, followed by the name of the function, parentheses, and a colon.     def hello():
                         To add parameters to your function, simply add one or more variable names in the parentheses, separated by commas.
                         It looks like you don't need to declare what data type your parameters can accept... HOWEVER, how those variables are used within
                         the function block will of course expect the values to be of a certain type... So it looks like it's up to the coder to keep
                         track of this.
- methods                just like a function, but it's called on a value.  This is very much like Ruby.  Call them with a dot "."  The main thing to
                         remember is that in Python, you need the closing parentheses, even if it's empty.  Each data type has its own built-in methods.
- array methods          FIND-- array.index("item_to_locate")    will return the index of the argument, if it exists (or the first instance of that argument
                            if duplicates exist.)
                         EXISTS?--  This is not a method, but something used in an if statement...   if "item" in array:    will return True or False.
                         PUSH-- array.append(item_to_add)  adds the item to the end of the list. MODIFIES ORIGINAL LIST
                         INSERT AT--  array.insert(index, item_to_insert) the item will take over that position in the
                            index, and everything gets shoved over one from there. MODIFIES ORIGINAL LIST
                         DELETE-- array.remove(item_to_remove)   removes the item (if it exists, error otherwise) and moves everything to fill the gap.
                            (note that if you want to delete by INDEX and not VALUE, you need to use the "del" keyword function, detailed above.)
                            (note that if duplicates exist, only the FIRST instance will be deleted.) MODIFIES ORIGINAL LIST
                         POP--  array.pop()  does 2 things... it RETURNS the last item in the list, AND, it MODIFIES ORIGINAL LIST by deleting that last item.
                         SORT--  array.sort()  sorts the array.  Works on strings and numbers, BUT not on lists containing BOTH strings and numbers.
                            CAUTION!  This sorts things in ASCIIbetical order, so capitals will ALWAYS come before lower-case. If you want to avoid this,
                            , use the optional keyword argument (key=str.lower) This option will NOT affect the values, just the sorting.
                            There is an optional keyword argument available, (reverse=True) to sort a list in reverse order. MODIFIES ORIGINAL LIST
                         REVERSE--  array.reverse()  reverses the items in a list AS THEY ARE. (i.e., it doesn't sort them, so don't get confused.)
                            This is not the same thing as the keyword "reverse" mentioned in SORT.  MODIFIES ORIGINAL LIST
- return values       =  In Python, you must explicitly use the "return" keyword followed by a value or an expression (that will be evaluated).
                         Note that the "return" line immediately exits the function, ignoring anything below that line.
                         Note that you can pass return values as arguments to other functions.
                         Any function that does not explicitly return anything, will return "None" by default (see next).  Likewise, when "return" is used
                         without anything after it, the result will also be "None".
- Nil/Null            =  In Python, the "lack of any value" value is called "None" (with a capital N).  None is its own data type, and is the only value possible.
- Error Handling      =  Use the "try" and "except" statements.  Code that could potentially throw an error is put into a "try" clause.  Then, if an error
                            DOES occur, rather than crashing, the code moves to the following "except" block.  For example, try dividing by zero....
                            def spam(divided_by):
                                try:
                                    return 42 / divided_by
                                except ZeroDivisionError:
                                    print("Error: Invalid argument.")
                            Note: When an error does occur, the code does NOT jump back into the "try" block.  It just keeps going from the except block.
                            Also note that you need the NAME of the error to use the "except" clause.  Here are some names I've encountered.
                            ZeroDivisionError, UnboundLocalError, TypeError, SyntaxError, KeyboardInterrupt, ValueError, IndexError, AttributeError, KeyError
                            FileNotFoundError, AssertionError
                        Debugging can be done with careful use of the 'raise' keyword.  It can be used like so...
                            raise Exception('This is not chicken. I ordered chicken.')
                            As you can see, it uses the 'raise' keyword, followed by a call to Exception().  If the raise was not covered by a try-except
                            block, the program simply crashes and displays the exception's error message.  See the "boxPrint.py" program for an example.
                            The way this usually works for custom errors is that you use an 'if' statement to detect something is wrong
                            within a custom function, first.   Once you've MADE your custom function, you will CALL it somewhere else in your code.
                            Put that CALL within a try/exception block.  If that 'wrong' thing is found, and an exception is thrown, it's like
                            the exception is 'returned' from your function, which is then 'caught' by the try/except block.  The message that you
                            attached to that particular error is what will be displayed.
                        Tracebacks   are a bunch of error information that includes the error message, the line number of the line that caused the error,
                            and the sequence of the function calls that led to the error.  The sequence of calls is called the "call stack".
                            If an error isn't handled specifically, the traceback is displayed by default, but you can "capture" it as a string using
                            traceback.format_exc()   which is in the traceback module (must be imported). So use that if you want to save the error logs.
                        Assertions   are "sanity checks" to make sure your code isn't doing something obviously wrong.  They are created as follows:
                            The 'assert' keyword, A conditional statement, a comma, and a string to display when the condition is false.
                                ages = [25, 85, 23, 11]
                                ages.sort()
                                assert ages[0] <= ages[-1], "The ages are not sorted!"
                            So, the assertion line checks to see if the first item in the array is less or equal to the last item.  If so, it does nothing
                            but if not, it crashes the program right then and there, giving an AssertionError with that message.
                            Note that these should only be seen/used by programers, NOT USERS.  Remove such code before production.
                            Also note that assertions can be flawed if you write them with flaws (that is, they dont actually check what you want,
                            leading to false positives/negatives.) So rigorous testing is still necessary.
- Debugging             The Logging Module --  This is a library you import at the top.  You need to "activate it" (my words, not the textbook's)
                            by including the following line of code, after all the import statements:
                                logging.basicConfig(level=logging.DEBUG, format=' %(asctime)s -  %(levelname)s -  %(message)s')
                            Don't worry too much about how that line works, basically when Python logs an event, it creates a LogRecord object
                                that holds information about that event.  See the program "factorialLog.py" for an example that has a bug in it on purpose.
                                asctime notes the timing of the event, levelname sets the minimum priority level needed for an event to be logged, and message
                                is of course the message.  There are 5 priority levels. Lowest is DEBUG, then INFO, WARNING, ERROR, and CRITICAL.
                            Once you have it set up, you can throw in this line of code...
                                logging.debug('Message to yourself for debugging purposes goes here.')  or  logging.warning('Looks bad bro!')
                                ...instead of using print() everywhere.  USE THIS FOR BEST PRACTICES!  It is superior to print() because you can
                                easily enable and disable ALL or SOME of the logs with one simple line of code, rather than manually searching through
                                and adding/removing various print() commands.  That command is    logging.disable(logging.CRITICAL) and it disables logs
                                at the given priority level or lower (so, "CRITICAL" would be all of them).  (Note however that you SHOULD use print() to
                                display info that the user WOULD want to see at some point.)
                            If you wanna log to a file instead of the console, you can add an extra argument to the front of the basicConfig line...
                                logging.basicConfig(filename='myProgramLog.txt', level=logging.DEBUG, format=bla bla bla...).
                                Each time you run the code, the textfile is APPENDED, not overwritten.
                            Breakpoint Debugging.  In VS Code you can add breakpoints to pause the code at certain points by activating the little reduce
                                dot in the margin, and then selecting the debug menu from the left-side navbar, and clicking "Run and Debug".
                                You will then get the (very small) navbar at the top of the screen where you can "step through" the various breakpoints.
                                The real-time values of your variables (both local and global) will be displayed on the left-side panel.
- PyInputPlus methods =   (requires pyinputplus library) these are for data validation. Using these functions automatically strips away leading and
                          trailing whitespace.  They can all be given the following optional keyword arguments:
                              blank=True   this option will allow inputs to be blank.  The default is that an answer is required.
                              limit=5   this option limits the number of tries the user has to enter a valid input.
                              timeout=60   this option limits the amount of time (in seconds) that the user has to enter a valid input.
                              default='some default'  If this option is included along with limit or timeout, then the default value will be returned
                                  instead of throwing an error.  (it seems that your default value does NOT need to match the input data type.)
                              allowRegexes=[r'yourRegexGoesHere', r'anotherRegexGoesHere', r'etc']   This option will only allow inputs if they match
                                  one of the given regexes in the list. (You must give this method a LIST of regexes, even if it's only one.)
                              blockRegexes=[r'yourRegexGoesHere', r'anotherRegexGoesHere', r'etc']   Reverse of the above.
                                  If you use BOTH allowRegexes AND blockRegexes, the allowRegexes result will override the blocking one.
                          inputStr() it's like the built-in input() function but has the general PyInputPlus features. You can also pass a custom validation
                              function to it.
                          inputInt() Ensures the user enters an integer (not a float). Returns an int.
                          inputFloat() Ensures the user enters a float (not an int). Returns a float.  (technically you can enter ints without a decimal
                              and it will just add a .0  on the end for you.)
                          inputNum() Ensures the user enters a number.  Returns an int or float depending on input.
                              The above 3 number-related methods have additional options that can be added as a second argument...
                                  - min=4   set the minimum requirement for the input. inclusive.
                                  - max=4   set the maximum limit for the input. inclusive.
                                  - greaterThan=4  same as min, but exclusive.
                                  - lessThan=4  same as max, but exclusive.
                          inputChoice()  Ensures the user enters one of the provided choices.
                          inputMenu() Is similar to input Choice(), but privides a menu with numbered or lettered options.
                          inputDatetime() Ensures the user enters a date and time.
                          inputYesNo() Ensures the user enters a 'yes' or 'no' response
                              additional options for this input are yesVal=""  and noVal="" so you can change languages if needed.
                          inputBool()  Is similar to above, but takes a 'True' or 'False' response and returns a boolean value.
                          inputEmail() Ensures the user enters a valid email address.
                          inputFilepath() Ensures the user enters a valid file path and filename, and can optionally check that a file with
                              that name exists.
                          inputPassword()  Is like the built-in input(), but displays * characters as the user types so that passwords, or other
                              sensitive information aren't displayed on the screen.
                          inputCustom()  allows you to pass in your own function to be used as a part of validation. You would do this by writing
                              the code for your custom function elsewhere, and then passing the name of that function into inputCustom.
                              REMEMBER!  When passing a function ITSELF, you don't use () after it because you are not calling it.
                              The reason you would use inputCustom() at all instead of just using the custom function itself, is that you can easily
                              combine your custom function with the built-in options listed at the top, such as blank, limit, default, etc...
- working with files  =   Path() First of all, it helps to import the Path() function by adding  "from pathlib import Path" at the top.  This function is a
                              filepath helper that can put together a correctly formatted filepath, given some arguments, and (I think) it works for any
                              OS system (Win, Mac, Lin). USE THIS.  If you don't you'll have to manually put together the various filepath styles for different
                              OS, which would be a real pain.  This function returns a "path object" apparently, which as far as I can tell, is like a string.
                          / When you want to concatenate strings, you use +, but for Path objects, you use /  .    Then you can do stuff like....
                                  Path('spam') / 'bacon' / 'eggs'
                                  Path('spam') / Path('bacon/eggs')
                                  Path('spam') / Path('bacon', 'eggs')
                              All 3 of these would evaluate to the same thing:  'spam/bacon/eggs'   The only thing to remember when using / like this is
                              that one of the first two values must be a Path object, otherwise you'll get an error.
                          CWD (Current Working Directory) any filenames or filepaths used in your code are assumed to be in the CWD if they do not include
                              the root directory.
                          Path.cwd() will return the current working directory. Remember, in Linux, you won't see C: or D:, you'll just see a /.  The letters
                              are strictly a Windows thing, and this (Ubuntu) is running on Linux/Posix
                          Path.home()   All users on the computer have a home folder for storing their files, and you can see it with this method.
                              On Windows, home directories are under C:\users
                              On Mac, home directories are under /Users
                              On Linux, home directories are often under /home   <--- this checks out, that's what I see on Ubuntu.
                          Absolute vs. Relative Paths.    An absolute path always begins with the root folder.  A relative path starts from the cwd.
                          Path(some_path).is_absolute()  returns True or False depending on the format of the path.
                          If you want to turn a relative path into an absolute path, just the Path.cwd() method and the / concatenator like so...
                              Path.cwd() / Path('my/relative/path')
                          .  and   ..   folders.  These are special names for folders.  A single dot means "this folder", double-dots means "parent folder".
                              The single dot version is optional; if you just start with the folder and/or filename, it does the same thing.
                          os.makedirs()  and  os.chdir() are for making and changing directories, respectively. (Just an FYI for a shortcut, you can
                              just write out a long filepath that doesn't exist yet when using os.makedirs, and all the necessary intermediate folders
                              that would be needed to get to the final file/folder are also created along the way.) Also, if you want to to write more
                              robust code that doesn't fail in case you already happen to have a folder of that name, you can add the keword argument
                              os.makedirs('some_name', exist_ok=True)
                          Path(some_path).mkdir() will turn a path object into a directory.  NOTE THAT THIS IS NOT THE SAME AS os.makedirs() !!!
                          os.path.abspath(path) will return a string of the absolute path of the argument. It's an easy way to make a relative an absolute.
                          os.path.isabs(path) will return True if the arg is an absolute path.
                          os.path.relpath(path, start) will return a string of a relative path from the start path to path.  If start is not provided, cwd is used instead
                          os.path.basename(path) will return just the basename (aka filename) of a path (or even a url!)
                          os.unlink(path) will delete a single file at "path"
                          os.rmdir(path) will delete the folder at "path", but it must be empty of any files or folders to work.
                          os.walk(string folder path) is usually used in a for loop to "walk" through a directory: that is, visit every file and subfile in
                              a given directory.  On each pass through the loop, it returns 3 values:
                                  a string of the current folder's name
                                  a LIST of STRINGS of the folders in the current folder
                                  a LIST of STRINGS of the FILES in the current folder.
                                  ("current folder" in this case means the folder for the current iteration of the loop, not the cwd.)
                              You can choose a variable name for the 3 values listed, such as "foldername", "subfolders", and "filenames".  Here's how to use it.
                                  for folderName, subfolders, filenames in os.walk('some folder path'):
                                      print('The current folder is ' + folderName)
                                      for subfolder in subfolders:
                                          print('Subfolder of ' + folderName + ': ' + subfolder)
                                      for filename in filenames:
                                          print('File inside ' + folderName + ': ' + filename)
                              this method returns a LIST of STRINGS.
                          Getting PARTS of a filepath:  The parts of a file path include the following,
                              The 'anchor', which is the root folder (basically just a slash  /) (Windows systems have a 'drive' letter before the anchor slash)
                              The 'parent', which is the folder that contains the file
                              The 'name' of the file, which is made up of the...
                                  'stem' (what you named it) and the
                                  'suffix  (the .txt .mp3 etc part.)
                              Once you have stored a Path object in a variable, you can get these parts easily...  p = Path('C:/Users/JD/spam.txt')
                                  p.anchor      gives    C:\\
                                  p.parent      gives    C:/Users/Al  <--- a Path object is returned, not a string.  The others all return strings.
                                  p.parents[0]  gives    a Path object corresponding to the full path given.  for each index you go up, the path
                                                         goes up the chain one folder.  parents[1] is one folder up from parents[0], and so on.
                                  p.name        gives    spam.txt
                                  p.stem        gives    spam
                                  p.suffix      gives    .txt
                                  p.drive       gives    C:
                          Find File Size:   os.path.getsize(path) will return the size in bytes of the file in the argument.
                          Find File Names:  os.listdir(path) will return a list/array of filename strings for each file in the path argument ()
                          Glob Patterns:  WTF is this? Huh. Path objects have a .glob() method which is used to list the contents of a folder according to A
                              "glob pattern"....  riiiight.  Glob patterns like a simplified form of regex that are often used in command line commands.
                              This method returns a "generator object" (seriously, wtf?) that you have to pass to list() to easily view in iPython3.
                              Let's look at some examples to wrap our noggin' around this...
                                  p = Path('/home/akakemushi/desktop')   <-- or some path like that...
                                  p.glob('*')   -->  will return something like: <generator object Path.glob at hexidecimal_number_here>
                                  list(p.glob('*'))   -->  will make a list from the generator.
                                  [PosixPath(blablabla.png), PosixPath(blablabla.pdf), PosixPath(blablabla.jpg) etc etc...]
                              In the above, the asterix * stands for "multiple of any characters", so it returns all files in the path. However, you can
                              create complex glob patters just as you can with regex, such as
                                  list(p.glob('*.txt'))    <--- this will only return the .txt files in that path.
                              The question mark (?) stands for any SINGLE character.
                                  list(p.glob('project?.docx'))    <---- would pick up files like  "project3.docx", "projectA.docx" etc..
                              You can combine * and ? anyway you like, such as....
                                  list(p.glob('*.?x?'))  <--- would pick up .exe files as well as .txt files.
                          Path Validity:  use p.exists() to see if a path exists (True) or not (False)
                              use p.is_file() to see if something exists AND if it's a file or not. (False if not, or doesn't exist)
                              use p.is_dir() to do the opposite of the above.
                              You can check to see if a flash drive is plugged in with these:  dDrive = Path('D:/')  ->  dDrive.exists() -> False
                              (not sure what the Linux equivalent is.)
                          Read / Write:   We're mostly working with plaintext files in this book.  ALL OTHER FILES are known as BINARY files, which
                              a text editor cannot display as intelligible text.
                              plaintext files are basically just long strings.  That's all they are.  You can read from them with p.read_text(), and
                              write to them using p.write_text('string').   .write_text will create a new file, or overwrite an existing one.
                                  from pathlib import Path
                                  p = Path('spam.txt')
                                  p.write_text('Hello, world!')
                                  13   <--- this output is just the length of the string you wrote.
                                  p.read_text()
                                  'Hello, world!'
                              Note that these two methods are limited.  Usually you need to call open(Path object or string here) first to get back a
                              File object. The path passed to open() can be absolute OR relative. Then you call read() or write() on the File object,
                              (Note that these are NOT read_text/write_text, as above.)  and finally call close(File object) on the object.
                              Opening files in this way only opens them in "read mode" by default, so you CANNOT modify them.  To do that, you need
                              to pass a second argument to the open() function, a "w" for "(over)write mode", or an "a" for "append mode".  (You can technically
                              also pass "r" for read mode, but that's not really neccessary since it's the default.)  Note that the write() method
                              does NOT automatically add a new line at the end like print() does. You have to do that manually.
                              Here's an example of how you'd get the text out of a file:
                                  helloFile = open('blablablafilepath.txt', 'w')
                                  content = helloFile.read()   -->  now "content" contains the string that was read from the helloFile
                              Similar to the limited functions described earlier, trying to write or append to a file that doesn't exist will create a new file.
                              You can also read a plaintext file line by line, storing the strings as items in a list. the \n character is the delimiter.
                          Shelf Files:    These are files used for storing other kinds of variable values that are not strings/plaintext
                              To use these, first import the library "shelve".  Then call shelve.open() and pass it a filename, storing the returned
                              shelf value in a variable. You can make changes to the shelf value as if it were a dictionary.  When you're done, call close()
                              on the shelf value. So a shelf file, is basically a hash/dictionary, and as you know, the keys in a dictionary can hold any kinda
                              of data type that you need.  Here's an example:
                                  import shelve
                                  shelfFile = shelve.open('mydata')  <-- IMPORTANT DISTINCTION: while the open() function can take a Path object or a string, the shelve.open() method ONLY takes strings.
                                  cats = ['Mr. Bigglesworth', 'Mr. Munch', 'Felix']
                                  shelfFile['cats'] = cats    <--- creating a new key in the shelfFile called cats, and setting the value to the cats list.
                                  shelfFile.close()
                              Shelve files are always in "write mode".  There are no options to change it.
                          SHUTIL module:   This module has functions for copying, moving, renaming and deleting files.
                              shutil.copy(source, destination)   does what it sounds like.Both source and dest can be strings or path objects.
                                  if destination is a filename, it will be used as the new name of the copied file.  This function returns
                                  a string or Path object of the copied file.
                              shutil.copytree() will copy an entire folder and every folder and file in it.
                              shutil.copytree(source, destination) will copy the folder at the path (source), along with all its fules and subfolders,
                                  to the (destination).  In this case, both the source and destination args are strings.  This function returns
                                  a string of the path of the copied folder.
                              shutil.move(source, destination) will move the file or folder at "source" to the "destination".  It returns
                                  a string of the absolute path of the new location. A few notes about this to avoid bugs...
                                  - If destination points to a folder, the source file gets moved into destination and keeps its current filename.
                                  - If the given folder exists, the file is moved into that folder, and a previous file of the same name is overwritten.
                                  - You can add a new filename to the end of the destination to rename the new (moved) file.
                                  - If the given folder DOESNT exist, then the new file gets RENAMED to the name of that non-existant folder without
                                    a file extention (a hard to spot bug!)
                              shutil.rmtree(path) will remove the folder at path, and all contained subfiles and subfolders. (By contrast, os.unlink and
                                  os.rmdir mentioned above only remove a single file or empty folder.)
                                  BE CAREFUL WITH THIS AND .MOVE!!  a tiny typo in a file extension could accidentally delete important stuff!
                                  A safe practice is to comment out the part in the loop that actually does the deleting, and add a "print" line to
                                  make sure the function does what you think it does.
                          send2trash.send2trash(string path) is a 3rd party library that just sends files to the recycle bin rather than delete them.
                          zipfiles     there is a zipfile module that is simply called "zipfile".
                              this module gives you the ability to access new objects called ZipFile and ZipInfo (with those capital letters).
                              creating a ZipFile is similar to creating a File object, and a ZipFile object has its own set of methods. Make them like this
                                  p = Path.home()
                                  exampleZip = zipfile.ZipFile(p / 'example.zip')
                                  exampleZip.namelist()  <--- will output the names of all the files in the zipfile.
                                  spamInfo = exampleZip.getinfo('spam.txt')  <---- .getinfo creates a "ZipInfo" object about that file.
                                  spamInfo.file_size    <---- will output the filesize in bytes as an int.
                                  spamInfo.compress_size  <--- will output the filesize when compressed.
                                  exampleZip.close()
                              To extract zipfiles, call ZipFileObjectHere.extractall()   This will extract all files to the cwd.
                              To extract a single zipfile, call .extract(file name here)
                              You can optionally add a location where you want the file to be extracted to, if you don't want cwd.
                              To CREATE a zipfile, you must pass the name of the file, and a second argument 'w', to put it in write mode.
                                  You can then use zipFileName.write('addedfilename.txt', compress_type=zipfile.ZIP_DEFLATED)
                              To ADD things to a zipfile, you must open the file in "append" mode by using 'a' as the argument, just like with files.
- requests (internet dl)  This is a module (3rd party) that allows you to download stuff off the internet.  It's easier and simpler than urllib2...
                              so don't even try that one (apparently).  Here are some of its functions.
                          requests.get(url_here) takes a string of a URL to download.  What you get back is not text, but a RESPONSE object, which has
                              its own methods and features.  For demonstration purposes, I'll call it "response" in later examples.  If you want to
                              save the downloaded file to your harddrive, you can do that by using open() and write() like with other files, with A
                              bit of a change.  First, you must open the file in "write binary" mode by using 'wb' as the second argument for open().
                              Next, you use the Response objects  .iter_content() method (see below).
                          type(response)  will say "class 'requests.models.Response'"   so that's its "data type" so to speak.
                          response.status_code contains an html response code like 200, 404, etc... you can look more up online if needed.
                          requests.codes.ok   (and presumably requests.codes.other_code_types_here) associates works with those numbers? Maybe?  Seems like it.
                          response.text  will give you the text recovered from that website (a .txt version of the html file)
                          response.raise_for_status()  will do nothing if the response was successful, otherwise it will raise an exception.
                              This method is a good way to make sure a program stops if a download fails. If, however, a failed download is NOT a dealbreaker
                              for your program, you can wrap it in a "try" and "except" block to handle the error, like the following example...
                                  import requests
                                  res = requests.get('https://inventwithpython.com/page_that_does_not_exist')
                                  try:
                                      res.raise_for_status()
                                  except Exception as exc:
                                      print('There was a problem: %s' % (exc))
                          response.iter_content(number of bytes goes here)  is used in a for loop to get a specified number of bytes at a time.
                              The number doesn't seem to matter as far as I can tell, but the book recommends 100000 (one hundred thousand).
                              The for loop created will go until the end of the file, and within this loop, you need to call write() to
                              write the current "chunk" of bytes to the HD.  Here's an example:
                                  <stuff to visit the page and download the file, saving it to a variable called "response" goes here...>
                                  myFile = open('someFileName.mp3', 'wb')
                                  for chunk in response.iter_content(100000):
                                      myFile.write(chunk)
                                  myFile.close()
- bs4 (internet dl)       This is short for "Beautiful Soup 4", a third-party module used to easily parse html files so you don't need to write complex
                              regex statements.  By running bs4.BeautifulSoup(response.text, 'html.parser'), it will return a "BeautifulSoup" object (lol)
                                  import requests, bs4
                                  response = requests.get('https://nostarch.com')
                                  res.raise_for_status()  <-- just to check for errors
                                  noStarchSoup = bs4.BeautifulSoup(response.text, 'html.parser')  <--- now "noStarchSoup" is a BeautifulSoup object.
                              Once you have the BS object (lol again) you have options for what to do with it through the following methods...
                          soup.select('div')                  all elements named <div>
                          soup.select('#author')              the element with an id attribute of 'author'
                          soup.select(.notice')               all elements that use a css class attribute named 'notice'
                          soup.select('div span')             all elements named <span> that are within an element named <div>
                          soup.select('div > span')           all elements named <span> that are DIRECT CHILDREN of an element named <div>
                          soup.select('input[name])           all elements named <input> that have a name attribute with any value
                          soup.select('input[type="button"]') all elements named <input> that have an attribute named type with value 'button'
                          soup.select('p #author')            the element with an id attribute of 'author', if it is also within a <p> element.
                              (Protip: in the browser dev tools, right click an element and select copy --> copy selector to quickly get the selector.)
                              all of these .selector() examples return a LIST of Tag objects, one per match found. If you want to see them, pass them
                              to str() to make them official strings and print them out. You can get at the individual Tags via normal array indexes.
                              tagList[0], tagList[1], etc...
                          someTag.getText() will return the INNER HTML string of the element.
                          someTag.attrs  will return a HASH of the attribute/value pairs (if any) in the element, such as {'id': 'author'}  (side note, why no () for the method call? hmm..)
                          someTag.get('some attribute goes here')  to get the value of that attribute (if it exists).
- selenium (internet dl?) Selenium is a module that opens a browser and manipulates it, simulating mouse clicks, filling in forms, etc, (kinda like
                              hotkeys? maybe?) It is slower than just using requests and bs4 because it MUST open a browser, but it is needed for more
                              sophisticated websites when Javascript and logins come into the mix.  For a bit of technical info, selenium is a way to get
                              around website defenses that look at the "user-agent" part of the http request to determine if you're a bot or not, because
                              selenium will be using your browser to make those requests.
                          Importing the selenium module into your code is a bit different... instead of "import selenium", you need to run "from selenium import webdriver"
                          JESUS CHRIST THIS THING IS DIFFICULT TO INSTALL ON WSL!!!  Still haven't figured it out yet... skipping for now.
- ezsheets (internet dl)  This is a module for working with xl files that are on google sheets.  Installing it was a bit of a pain in the ass, but I
                              eventually got there.  The hard part was getting these three files into the repository - credentials-sheets.json, and then
                              token-drive.pickle and token-sheets.pickle  .   All I can say is that trying over and over again to import ezsheets, getting
                              the localhost up as fast as possible eventually worked... I really don't know how I got those pickle files, but somehow I did.
                          ezsheets.Spreadsheet('id string of a file you have on google sheets goes here') will create a Spreadsheet object that you can
                              work with inside of your code. You can also use the title of the spreadsheet (if there is only one with that name), or the
                              full URL, (which honestly sounds like more work that is neccessary, but the option is there.)
                          ezsheets.createSpreadsheet('Title of Spreadsheet')  will create a new spreadsheet (creates it online! neat!)
                          ezsheets.upload('my_spreadsheet.xlsx')  will upload an existing xlsx file to google
                          ezsheets.listSpreadsheets()  will return a hash(dictionary) of all the sheets you have on google, with their ids and titles as
                              key-value pairs
                          ezsheets.convertAddress('A2') turns this string into the tuple (1, 2)
                                                 (1, 2) it will ALSO work in reverse, changing this tuple into the string 'A2'
                          ezsheets.getColumnLetterOf(2)  will return 'B'
                          ezsheets.getColumnNumberOf('B') will return the int 2
                              The above 3 methods become useful when you get really really BIG tables... what letter is column 1,354 for example?
                          Spreadsheet object Attributes/Methods:
                              myspreadsheet.title  returns the title of the spreadsheet.
                              myspreadsheet.title = "something else"    changes the title.
                              myspreadsheet.spreadsheetId    returns the ID of the sheet (read-only)
                              myspreadsheet.url   returns the full URL of the sheet (read-only)
                              myspreadsheet.sheetTitles   returns the titles of all the Sheet objects (A Spreadsheet object can have many "Sheet" objects)
                              myspreadsheet.sheets   returns the Sheet objects in this Spreadsheet, in order.
                              myspreadsheet[0]   is the first Sheet object in this Spreadsheet. (Functionally equivalent to myspreadsheet.sheets[0])
                              myspreadsheet['Students']   Sheet objects can also be accessed through titles.
                              myspreadsheet.delete()   deletes the entire spreadsheet.
                              myspreadsheet[0].delete()   deletes the first sheet within the spreadsheet.
                              myspreadsheet.createSheet('New Name')   will create a new sheet at the end of the list of sheets
                              myspreadsheet.createSheet('New Name', 0)  will create a new sheet at the specified index of sheets.
                              del myspreadsheet[0]   Deletes the first Sheet object in this Spreadsheet.
                              myspreadsheet.refresh()    checks online and syncronizes the data in the local spreadsheet with the one online if any
                                  changes are detected.
                              Downloading and Uploading
                                  You can convert the xlsx files into other filetypes with these commands...
                                      myspreadsheet.downloadAsExcel()  .downloadAsODS()  .downloadAsCSV()  .downloadAsTSV()  .downloadAsPDF() .downloadAsHTML()
                                  No matter which one you use, it returns a string of the downloaded file's filename.  You can also specify the filename by
                                  passing the new filename to the download function as a string, such as 'some_file.xlsx'
                              Copying sheets into another spreadsheet...
                                  If you wanna copy a whole sheet from one Spreadsheet and add it (not overwrite) to a different spreadsheet, use this...
                                      spreadsheetone[0].copyTo(spreadsheettwo)
                          Sheet object Attributes/Methods  (again, note that Sheets are held within a Spreadsheet)
                              mysheet['A1']    reads the value in cell A1  (empty cells return a blank string)
                              mysheet['A1'] = 'Name'   Sets the value in cell A1
                              mysheet[1, 1] is functionally equivalent to mysheet['A1'].  Note the usage of quotes in each case, and also that the first
                                  number is 1, not 0.  For sheet cells, indexes start at 1.
                              mysheet.refresh()   syncronizes with any changes in the online version.
                              mysheet.delete()   deletes the whole sheet
                              mysheet.clear()   clears all the cells within the sheet, but the sheet itself remains. (important distinction)
                              mysheet.getRow(1)   will return an array/list of all the values stored across row 1. Note that it returns quite a few blank
                                  cells beyond the "end" of your table... not sure how the number of cells returned is determined though. <<SOLVED>> The number
                                  of rows is set when the sheet is created (there may be some defaults or something).
                              mysheet.getColumn(1)  will return an array/list of all the values stored down column 1
                                  note that you can use letters instead of numbers for the above methods.
                              mysheet.updateRow(3, ['Pumpkin', '11.50', '20', '230'])   will OVERWRITE that row with the data in the array given, EVEN
                                  DATA BEYOND WHAT YOUR ARRAY INCLUDES WILL BE RESET!! So beware.  In this example, columns E, F, G... would all be "reset" to blank.
                              mysheet.updateColumn(2, ['bla', 'bla', 'bla']) like the above.
                                  you can also iterate over these lists if needed like so:
                                      columnOne = sheet.getColumn(1)
                                      for i, value in enumerate(columnOne):
                                          columnOne[i] = value.upper()
                                  ... and then use your modified column or row...
                                      sheet.updateColumn(1, columnOne)
                              rows = sheet.getRows()   will return an array of arrays (matrix) of ALL your rows.  You can then access them like this...
                                  rows[0]  gives the array of cells in row 1..
                                  rows[1][0]  gives the data in the cell A2
                                  you can change the values with the = operator as usual.
                              sheet.updateRows(rows) (assuming you stored the matrix in a variable called "rows" like above)  This will update your sheet with
                                  the data stored in your variable.
                              sheet.rowCount   returns the number of rows in your sheet.
                              sheet.columnCount  returns the number of columns
                              sheet.columnCount (or .rowCount) =  4   You can change the size of your sheet with =
                                  Naturally, if you make it smaller, columns/rows that now fall outside of its new size will be deleted, and their data too.
                          Final points:  Google sheets has a usage limit of 250 new spreadsheets a day, and 100 read and 100 write requests per 100 seconds.
                              Attempting to exceed this limit will raise the googleapiclient.errors.HttpError "Quota exceeded for quota group". So, if you
                              write some scripts and they start behaving weird, this may be why if you're working with a LOT of data.
                              For a complete list of all of ezsheet's features, go to ezsheets.readthedocs.io
PyPDF2 (internet dl)      This module is for working with PDFs.  It seems like the file needs to be stored locally (if online usage is possible, i
                              don't know.) import with     'import PyPDF2'   You can read the text off of pdfs and create your own (sort of).  The
                              creation aspect is limited to just copying pages from other pdfs, rotating them, overlaying (for timestamps and logos
                              and watermarks and stuff...), and encrypting. Some stuff you could use this for are: cutting out specific pages from a pdf,
                              reordering pages in a pdf, and creating a new pdf from only those pages that have some specific text.
                          FOR READING PDFs....
                          myPDF = open('filename.pdf', 'rb')  step 1:  open the file in "read binary" mode.
                          myPyPDF = PyPDF2.PdfFileReader(myPDF)    step 2:  create a PyPDF object from the open file. Now you have options to work with it.
                          myPyPDF.isEncrypted    will return True or False, telling you if the file is password protected or not.
                          myPyPDF.decrypt('password')   will unlock the file for use (returning 1 if successful and 0 if not.)  Note that this only
                              decrypts the PyPDF object, not the actual original PDF.
                          myPyPDF.numPages   returns the number of pages in the pdf as an int.
                          myPage = myPyPDF.getPage(0)  <--  function for getting a single page object from the whole pdf and storing it in a variable.
                              note that this system is zero-indexed, like an array.
                          myPage.extractText()  <--  returns a string with all of the text on that page.  This is imperfect, as sometimes the "text"
                              you see in the PDF isn't text at all, but an image.  It can also make mistakes with spacing, etc.
                          myPage.rotateClockwise(90)   will rotate the pdf x degrees
                          myPage.rotateCounterClockwise(90)   same
                          myPage.mergePage(anotherPage)   will overlay the page in the argument on top of the base page (I guess there's something like
                              an alpha channel in play here.)
                          FOR WRITING PDFs....
                          newPDF = open('myNewFile.pdf', 'wb')   step 1:  open a new file in "write binary" mode.  Name it whatever you want.
                              This will be the file that gets saved to the HD in the end, but for now it's just blank.
                              step 2: open any other preexisting pdfs using the above methods and making PyPDF objects out of them.
                          pdfWriter = PyPDF2.PdfFileWriter()   step 3:  create the running code version of the PDF.  We make additions and changes here,
                              and as a last step this gets saved to the new file that we opened earlier.  It's basically a temporary PDF sandbox.
                          pdfWriter.addPage(myPage)   You can add pages to the writer object like this, once you've copied them from an old pdf.
                              Pages are always added to the end of the pdf.  You can't put them in the middle or anything.
                          pdfWriter.write(newPDF)  step 4: finally, you "save" the file by writing your changes to the blank pdf. (dont forget run close())
                          pdfWriter.encrypt('password you want')    use this before writing if you want to add encryption to the pdf.  You can actually
                              have TWO passwords; a user password (allowing viewing), and an owner password (allowing you to set permissions for printing
                              commenting, extracting text, and more).  The user password and owner pw are the first and second arguments passed to .encrypt()
                              respectively.  If only one string argument is passed, it will be used to set both passwords.
                          You can't create PDF documents directly with this, but you can generate PDF files if you're on Windows and have MS Word.  I won'T
                              go into it here, just know that it exists, and you need to install   pip install --user -U pywin32==224
python-docx (net dl)      This module works with Word documents (.docx).  NOTE!!  when INSTALLING, it is called "python-docx", but when IMPORTING it is
                              simply done with  "import docx".  There is actually a different module that is just called "docx", so don't make that
                              mistake.   .docx are more complex than .txt and can be represented by 3 data-types.  a "Document" object representing
                              the whole document (has a list of Paragraph objects, which are created whenever the user hits the "enter" key), "Paragraph"
                              objects which contain a list of one or more "Run" objects. This last one is the most unintuitive, but it's really not that
                              hard.  It's just a "run" of text that uses the same formatting, such as bold, italics, font, size, color.... So A
                              single "run" covers all the consecutive characters up to the point that the style changes, at which point a new "run"
                              begins.  If you don't care about style and just want the text, it seems like you have to write your own custom funciton...
                                  import docx
                                  def getText(filename):
                                      doc = docx.Document(filename)
                                      fullText = []
                                      for para in doc.paragraphs:
                                          fullText.append(para.text)
                                      return '\n'.join(fullText)
                              Create a new file named "readDocx.py" or whatever, enter the above code and save it.  Now you can import that "readDocx"
                          doc = docx.Document('filename to open.docx')    First, create a Document object from a file. Now you can work with it.
                          len(doc.paragraphs)  returns the number of Paragraph objects in the doc.
                          doc.paragraphs[0].text   returns a string with the text in the first paragraph.
                          doc.paragraphs[1].runs[0].text   returnst a string with the text in the first run of the second paragraph.
                          Paragraph and Run objects have a "style" attribute which can be set to a number of predefined styles (denoted by strings)
                          There are "paragraph" styles for paragraphs, "character" styles for runs, and "linked" styles that work for both (linked styles below)
                              Normal        Heading 5       List Bullet       List Paragraph
                              Body text     Heading 6       List Bullet 2     MacroText
                              Body Text 2   Heading 7       List Bullet 3     No spacing
                              Body Text 3   Heading 8       List Continue     Quote
                              Caption       Heading 9       List Continue 2   Subtitle
                              Heading 1     Intense Quote   List Continue 3   TOC Heading
                              Heading 2     List            List Number       Title
                              Heading 3     List 2          List Number 2
                              Heading 4     List 3          List Number 3     None   <--  for no style.
                          When using a linked style for a Run object, you will need to add ' Char' to the end of its name, so 'Quote' becomes 'Quote Char'.
                          Also note that python-docx CANNOT add any styles beyond the default ones, BUT!  It IS possible to add new styles using MS Word
                          itself (or similar app), save the file, and then open it in python-docx. If you do it that way, those new style will become
                          available to use in your code (apparently.  Havent tried it yet). Specifically, you need to use the "Create New Style" features
                          in Word to do this. Runs can be further styled using text attributes.  Each attribute can be set to one of three values:
                              True: The attribute is always enabled, no matter what other styles are applied to the run
                              False: The attribute is always disabled
                              None: Defaults to whatever the run's style is set To
                          The following are the attributes that run objects have:
                              bold, italic, underline, strike, double_strike, all_caps, shadow, outline, rtl (written right to left), imprint, emboss
                          To create a new file from scratch, do something like:
                              doc = docx.Document()
                              doc.add_paragraph('Text you wanna add goes here')
                              doc.save('myfilename.docx')
                              ...and voila, it's done.
                          Whenever you call the .add_paragraph() method it makes a NEW paragraph.  If you want to ADD to an EXISTING paragraph, first
                              you need to get that paragraph and save it to a variable as a paragraph object, such as   paraObj1 = doc.add_paragraph('Your text')
                              Then you can add to that paragraph specifically with paraObj1.add_run('more text')   (don't forget to save with doc.save)
                              You can save run object to variables as well if you want to.
                          Both add_paragraph() and add_run() accept an optional second argument that is a string of the Paragraph or Run object's style.
                              doc.add_paragraph('Hello, world!', 'Title')   This will add the paragraph with the Title style applied to it.
                          .add_heading('Heading title', 1) works much the same, but only for headers that can have a "style" which is an integer from 0 to 4.
                              Note that this function returns a paragraph object, but exists because its second argument can be an int, not a string.
                          runObject.add_break will add a line break without starting a new paragraph object.   If you need a page break instead,
                              you need to pass the value,  docx.enum.text.WD_BREAK.PAGE as a lone argument to add_break()  (it's a mouthful, but that's just
                              how it works...)  A page break will, of course, force the text after it to appear on the following page, even if there was
                              still space left on the previous page.
                          .add_picture('filename.png', width=docx.shared.Inches(1), height=docx.shared.Cm(4))  will add the pic to the end of the doc (I'made
                              not sure which img file types are allowed with this...)  also, the height and width are optional, leaving them blank will
                              use the pictures acutal height and width.
CSV FILES                 I know this, but a quick refresher: comma-separated values.  everything is a string, so no data-types. No cells, formats, etc. Very simple.
                              use the csv module to handle csv files.  If you just treat them as strings, you'll run into problems parsing the commas, since
                              csv files have their own escape characters and stuff.
                          the built-in python module is just called "csv" so you can do   import csv
                          First, open the file with open() and put it in a variable     exampleFile = open('example.csv')
                          Next, make a csv reader object from that file object...     exampleReader = csv.reader(exampleFile)
                          Now you can work with the data....       exampleData = list(exampleReader)  exampleData is a matrix (array of arrays)
                              so you can access anything with the standard index format:   exampleData[1][2]   etc...
                          For really big files, you might not want to load the WHOLE thing into memory all at once, so use a FOR loop instead...
                              for row in exampleReader:
                                  print('Row #' + str(exampleReader.line_num) + ' ' + str(row))     ... or whatever you wanna do with it.
                              NOTE!!  For some reason, you can only loop over a Reader object ONCE, then it's... gone?  I guess?  You have to make a new one
                              if you wanna loop over the object again.  Maybe that's why it's a good idea to convert the object to a data matrix?
                          exampleReader.line_num   apparently returns an int of the line number you're currently on in the loop?  weird...
                          Writer Object -  use to write stuff to a CSV file.  To create one, use the csv.writer() function.
                              outputFile = open('output.csv', 'w', newline='') <-- (technical issue with windows, so the keyword arg is needed)
                              outputWriter = csv.writer(outputFile)
                              outputWriter.writerow(['spam', 'eggs', 'bacon', 'ham'])
                              outputWriter.writerow(['Hello, world!', 'eggs', 'bacon', 'ham']) <-- note the comma in Hello, world will be handled by the module.
                              outputFile.close()
                          .tsv file is same as csv, but TAB separated values.  These functions are still within the csv module though.
                              csvFile = open('example.tsv', 'w', newline='')
                              csvWriter = csv.writer(csvFile, delimiter='\t', lineterminator='\n')  <--- set the delimiter to a tab instead of a comma.
                              csvWriter.writerow(['apples', 'oranges', 'bananas'])
                          DictReader Objects  -  csv files can have header rows, if you'll recall from Ruby.  For these, you might want this object.
                              This object reads csv file rows by using dictionaries(hashes) instead of lists(arrays), and they use the first row of
                              the csv file as the keys of these dictionaries.  If you don't have header names, you can supply them on the spot like so..
                                  exampleDictReader = csv.DictReader(exampleFile, ['header1', 'header2', 'header3'])
                          DictWriter Objects  -  For making and alterning csv files with headers.
                              First open an output file like so...
                                  outputFile = open('output.csv', 'w', newline='')
                              then make a DictWriter object that points to it...
                                  outputDictWriter = csv.DictWriter(outputFile, ['Name', 'Pet', 'Phone'])
                              note: the array above is required because we're creating hashes, and this DictWriter needs a way to confirm which keys are
                              valid keys when you make new rows. I experimented with this, and indeed, trying to use an invalid key won't work.
                              If you want your file to contain a header row, write that row by calling writeheader()
                                  outputDictWriter.writeheader()    <--- will take the array in the arguments and make a row from them.
                              otherwise skip it to omit a header row.
JSON  (built-in module)   As expected, has functions related to JSON objects, useful for talking to APIs. As you know, JSON can represent the basic
                              data tyles like strings, floats, booleans, arrays, hashes and "None", but not the more complex ones like file objects.
                          json.loads() --> myPythonDict = json.loads(stringOfJsonData) will return the JSON as a dictionary/hash. (trivial note here:, the method name
                              "loads" is actually more like "load s", short for "load string".  Not that it really matters.)
                              Note: JSON strings MUST use double-quotes inside the curly-brackets!!   example JSON:
                                  myJSONString = '{"name": "Zophie", "isCat": true, "miceCaught": 0, "felineIQ": null}'
                              Note: Python dictionaries are not ordered, so the key-value pairs might be in a different order than the JSON. That's ok.
                          json.dumps() -->  stringOfJsonData = json.dumps(pythonValue) will translate a Python value into a string of JSON formatted data.
                              Playing around with this, I found that the translation only makes minor visible changes, the main thing to note is that
                              conversion to a json means it is a single string as far as python is concerned, even floats, ints, and arrays.
                              Other than that, single quotes become double quotes, True/False become true/false, and None becomes null
time module(built in)     time.time()  will return a FLOAT representing the current "epoch timestamp" (which is how many seconds have passed since
                              January 1, 1970, 12am (UTC), weird I know, but it's a thing apparently. It's also called "Unix epoch"). You can use
                              this stamp to "profile" your code, or see how long it takes to run by subtracting the first timestamp from the second.
                              (This usage isn't really necessary though since cProfile module exists...)
                          time.ctime()  will return a string description of the current time, like "Fri Nov 29 18:07:50 2024", and if you have an
                              epoch timestamp (see above) already, you can pass it to this method to get a string version of that point in time.
                          time.sleep()  will pause the program for some number (expressed in seconds as a float or int)
datetime module           the "time" module is good for unix epoch time and timers, but for more "readable" times and for doing math with dates and
                              times, the datetime module is what you need.  This module has its OWN DATATYPES, the datetime.datetime datatype (representing
                              a MOMENT in time), and the timedelta datatype (representing a DURATION of time).
                          datetime.datetime.now() will return something like:  datetime.datetime(year, month, day, hour, min, sec, sub-sec), where
                              each of those words are replaced with a number, like (2024, 11, 29, 18, 45, 0, 123456).  You can save this value into
                              a variable, and then access its properties.  I'll use "dt" as the variable name below.
                          datetime.datetime(2024, 11, 29, 18, 45, 0) will CREATE a datetime object using the ints you feed it (doing some experimenting,
                              I learned that if you don't include all the numbers, they are just set to 0, and if you include an imposible number, such
                              as "13" for the month, you get an error, so it won't let you make impossible dates. It's even smart enough to know how
                              many days are in each month!  You can't make February 30th, for example.  I wonder if it does leap years too??)
                          dt.year  returns the year (as an int)
                              the others are intuitive, dt.month, dt.day, dt.hour, dt.minute, dt.second, and dt.microsecond
                          dt.strftime()   returns a nicely formatted string of the datetime object you call it on. You must supply it with a string
                              to use it.  This string accepts special variables that will be interpolated as follows...
                                  Special Variables and their meanings:
                                      %Y    Year with century, as in 2024
                                      %y    Year without century, 00 to 99
                                      %m    Month as a number, 01 to 12
                                      %B    Full month name, like "November"
                                      %b    Abbreviated month, like 'Nov'
                                      %d    Day of the month, 01 to 31
                                      %j    Day of the year, 001 to 366
                                      %w    Day of the week, 0 (Sunday) to 6 (Saturday)
                                      %A    Weekday name, like "Monday"
                                      %a    Abbreviated weekday, like "Mon"
                                      %H    Hour (24 hr time)  00 to 23
                                      %I    Hour (12 hr time)  01 to 12
                                      %M    Minute, 00 to 59
                                      %S    Second, 00 to 59
                                      %p    AM or PM
                                      %%    (Literal % character)
                                  You can freely mix and match these variables in any order, and with other non-variable characters as you like...
                                      "%Y/%m/%d %H:%M:%S" -->  2019/10/21 16:29:32     "%B %d, %Y --> October 21, 2019
                                      "I don't like %As." -->  I don't like Mondays.
                          datetime.datetime.strptime("A string", "A Format to use")  will parse a string into a datetime object, using the format you
                              pass to it.  The format string is exactly like the ones you can pass to strftime() above.  Just make sure the string
                              fits the format you give it.   Example:  datetime.datetime.strptime("October of '19", "%B of '%y")
                          datetime.datetime.fromtimestamp(epoch timestamp) will convert an epoch timestamp to the datetime format.
                          datetime.timedelta(days=11, hours=10, minutes=9, seconds=9)     will make a timedelta object.  Note there is NOT a "month"
                              or "year" argument you can set, because the length of months and years is variable.  There IS however a "week",
                              "millisecond" and "microsecond" option you can pass in. You can do math with timedelta objects like so:
                                  dt = datetime.datetime.now()
                                  thousandDays = datetime.timedelta(days=1000)
                                  thousandDaysFromNow = dt + thousandDays
                              You can also make a program "pause" until a certain date by using this math in conjunction with time.sleep and a loop...
                                  halloween2030 = datetime.datetime(2016, 10, 31, 0, 0, 0)
                                  while datetime.datetime.now() < halloween2030:
                                      time.sleep(1)
                          delta.days, delta.seconds, delta.microseconds will return, IN ORDER the number of WHOLE days (24 hrs) within the total duration,
                              and then once the maximum number of days is subtracted, it returns the number of WHOLE seconds from that, and then the
                              number of microseconds... it's kinda weird.  no other options seem to be available than those three.
                          delta.total_seconds()   will return the duration in number of seconds alone.
                          str(delta)  will give you a nicely formatted string of the date.
-Threading (built-in)     The threading module allows you to create thread objects that can perform "background tasks".
                          Note that NORMALLY a python program automatically ends after executing the final line of code,
                          however if you have multiple threads, then it won't terminate until ALL threads have terminated.
                          To make a separate thread, you first need to make a Thread object by calling the threading.Thread() function.
                              import threading, time
                              print('Start of program.')
                              def takeANap():
                                  time.sleep(10)
                                  print('Wake up!')
                              threadObj = threading.Thread(target=takeANap)
                              threadObj.start()
                              print('End of program.')
                          NOTE!!  you pass the keyword argument takeANap, not takeANap().  We wanna pass the function itself, not call it.
                          threadObj.join()  is a way to make a program wait until that thread is done.  To use it, you first make a thread object
                              as written above, then later in your MAIN code, you would call the extra thread's .join method from the main program.
                              By doing so, the main program will "wait" for that particular thread to "rejoin" the main thread before moving on to the
                              next line of code.
                          If the target function you want to run in the new thread takes arguments, you can pass the target function's arguments
                          to threading.Thread() as a list, and any keyword arguments as a dictionary.
                              threadObj = threading.Thread(target=print, args=['Cats', 'Dogs', 'Frogs'], kwargs={'sep': ' & '})
                              threadObj.start()
                              (output will be )  "Cats & Dogs & Frogs"
                          This is worth mentioning again: You CANNOT do this...  threadObj = threading.Thread(target=print('Cats', 'Dogs', 'Frogs', sep=' & '))
                          ... all that would do is pass the returned value of the print function to .Thread (which is None).
                          -CONCURRENCY ISSUES-   This can happen when you have multiple threads reading/writing to the same variables and getting in each
                          other's way, and such bugs are hard to reproduce and debug. As a rule of thumb, try to only use local variables within the function
                          passed into the new thread.
                          PROCESSES vs THREADS   A process is a whole program being executed, and can contain many threads.  If you have multiple browsers
                              open for example, then you have multiple processes going.  Unlike threads, processes CANNOT read or write each other's variables.
- subprocess              this built-in module can launch other programs from Python using the Popen() function (though it is annoying to use on WSL ubuntu...)
                          To use this with WSL Ubuntu and open programs that are on the Windows side of things, you'll need to path through /mnt like this..
                              "/mnt/c/Windows/System32/calc.exe".  I don't know if /mnt/d or other drives are available like this...
                              once you open a process(program) like this, it returns a Popen object, which has some methods you can play with.
                              poll() and wait().
                                  The "poll()" method is like asking the driver "are we there yet?" over and over.  It will return "None"
                                      if the process is still running at the time poll() is called, otherwise, it will return the "exit code", which is an int.
                                      Generally an exit code of 0 means there were no errors, or another int if there was an error.
                                  The "wait()" method is like waiting until the driver has arrived at your destination.  It will block until the process
                                      has terminated.  Use this if you want to pause until the user finishes with the other program.  It also returns
                                      the process's exit code.
                          You can pass command line arguments to processes you create with Popen() as a list.  The first string in this list will
                              be the executable filename of the program you want to launch; all the subsequent strings will be the command line args,
                              in effect becoming the value of sys.argv for the launched program. (Most GUI programs dont extensively use command line args
                              , but might accept a filename that they will immediately open when they start.)
- ezgmail (dl needed) =   Similar to the ezsheets module, this module uses the google api to access and use features of gmail.  I seem to have already
                              set up the OAuthentication from the previous ezsheets project, so I already have a "credentials-sheets.json" file.
                              So, to get started, import the ezgmail module, and then you can do stuff like the following...
                                  ezgmail.init()    will initiate the connection (I guess?)
                                  ezgmail.send('targetemail@domain.com', 'Subject Line', 'body of email')     this will send an email via the gmail
                                      account that you have signed in with.  Optionally, you can include a 4th argument, a list [] of strings that are the
                                      files you want to attach...   ..., ['attachment1.jpg', 'attachment2.jpg'])    (Note that gmail will likely block
                                      any files that are repeated or .exe or .zip files because google will think they are viruses.)
                                      you can also, use the keyword args   cc="anotheremail@blabla.com", bcc="otheremail@blabla.com"
                                  ezgmail.EMAIL_ADDRESS  will return the email address that the token.json file is configured for.
                                  ezgmail.unread() will return a list of "GmailThread" objects, which you should save into a variable.
                                      GmailThread objects each have a .messages attribute, which is a list of each email in the message thread. (So,
                                      all messages will have at least 1 message, but could have more, if replies were made.) Here is a short code example
                                      of how you can access the data...
                                          import ezgmail
                                          unreadThreads = ezgmail.unread()
                                          str(unreadThreads[0].messages[0])   <--- would return a stringified version of the first email in the first thread.
                                          str(unreadThreads[1].messages[2].subject)  <--- would return the subject of the third email in the second thread.
                                      Other attributes of the .messages attribute are: .subject, .body, .timestamp, .sender, .recipient, .attachments
                                  ezgmail.summary(some list of GmailThread objects)  will display a quick summary of the email threads.  **Note, GmailThread
                                      keeps track of emails and direct replies as a "conversation thread", even if there is only one email.
                                  ezgmail.recent() is similar to ezgmail.unread(), except if returns the most recent threads.  The default amount is 25,
                                      however you can alter this with the keyword arg maxResults=100 or some other int.
                                  ezgmail.search() works just like searching for emails in the Gmail searchbox.  Just put the search term as a string.
                                      you can also pass any of the special search operators that you can enter into the search box to the search()
                                      function, such as.. 'label:UNREAD', 'from:someEmail@bla.com', 'subject:hello', 'has:attachment', and more.
                                      see https://support.google.com/mail/answer/7190?hl=en/   for more.
                                  .downloadAttachment('filename.jpg')  is a method that can be called on a GmailMessage object to dl the attachment. Example:
                                      import ezgmail
                                      threads = ezgmail.search('vacation photos')
                                      threads[0].messages[0].attachments  (will return a list of filenames, which you can store or print out...)
                                      (example output) ['tulips.jpg', 'canal.jpg', 'bicycles.jpg']
                                      threads[0].messages[0].downloadAttachment('tulips.jpg')   <--- here's how you'd use it.
                                  .downloadAllAttachments() will do the same as the above, but dl all the attachments, as the name suggests.
                                      note that both .downloadAttachment and .downloadAllAttachments can take an optional keyword argument to change the
                                      directory in which the files will be downloaded, which is   downloadFolder='folderNameHere'   .  Also note that
                                      duplicate filenames will automatically be overwritten, so be warned.
                                  Other Features -- ezgmail contains additional features found at  https://github.com/asweigart/ezgmail/
- smtplib  (built-in)     SMTP stands for Simple Mail Transfer Protocol, and is like the brother of HTTP, but for Email.  It dictates how email messages
                              should be formatted, encrypted, and relayed between mail servers and all the other details that your computer handles
                              after you click send.  IT ONLY DEALS WITH SENDING!  Not retrieving emails from others. (for that, see IMAP)
                              Most email providers have other security measures in place to protect against spam, phishing etc. These measures
                              prevent Python scripts from logging in to an email account with the smtplib and imapclient modules, however many of these
                              services have APIs and specific Python modules that allow scripts to access them.
- imapclient (dl needed)  IMAP stands for Internet Message Access Protocol, and it specifies how to communicate with an email provider'S
                              server to retrieve emails sent to your email address.  It is my understanding that as long as I can use the ezgmail module,
                              both this and the smtp module are entirely unneccessary... so I'm not gonna bother taking notes on them unless I really
                              need to later on.  For reference, this info was on pages 420 - 433.
- pillow (dl needed)      Pillow is a third-party module for handling image files.  You can crop, resize, and edit the content of an image.
                              colors in Pillow are represented as RGBA tuples like: (255, 0, 0, 255) for red.  It also uses the same color standards
                              as HTML does, so for example, the keyword "yellow" would correspond to the tuple (255, 255, 0, 255).
                              Many of Pillow's functions also use a "box tuple" argument, which is a tuple of exactly 4 ints that represent the following:
                                  1. Left - The x-coordinate of the leftmost edge of the box.
                                  2. Top - The y-coordinate of the top edge of the box.
                                  3. Right - The x-coord of one pixel to the right of the rightmost edge of the box.  This integer must be greater than Left.
                                  4. Bottom - The y-coord of one pixel lower than the bottom edge of the box.  This integer must be greater than Top.
                              To import pillow, you need to do    from PIL import Image   or   from PIL import ImageColor.
                          ImageColor.getcolor()  takes a color name (a string) as its first arg, and 'RGBA' as its second arg.  It returns an RGBA tuple.
                              (the color string you input is not case sensitive, so RED, Red and red all work.)  There are like over 100 standard colors,
                              so you might be able to just "guess" at the name of a specific color and get really lucky.  Some examples (just to name a few)
                              ghostwhite, goldenrod, ivory, khaki, lightsalmon, navy, hotpink... so yea, there's quite a few.
                          Image.new() will create a new blank image.  It needs the following args:
                              1. The string'RGBA', which sets the color mode to RGBA.  (There are others though.)
                              2. The size, as a two-int tuple of the image's width and height.
                              3. The background color that the image should start with, as a four-int tuple of an RGBA value. (Feel free to use the
                                  .getcolor() function above to get a return value here).  You can also just pass it a color name string like "red".
                          Image.open('filename.png') will return an Image object you can work with, so you need to save it in a variable.  If the file you
                              want to open is NOT in the current working directory, you can import os and use the os.chdir function to navigate to that
                              folder first.
                          .save will save any changes you make to the Image object.  Also, it auto-converts the file into whatever format you specified.
                          .size will return a tuple of the width and height of the Image object in pixels.
                              you can quickly extract this info with the multi-assignment trick...  width, height = catIm.size
                          .filename  will return the filename of the Image object (if you need it for some reason?)
                          .format  will return the format (jpg, png, etc..) of the Image.
                          .format_description   will return the long-form name of the format, such as "Portable Network Graphics" (aka PNG)
                          .crop  will take a box tuple and return an Image object representing the cropped image.  Note that the original object is not
                              changed; a new Image object is created, so you'd need to save it in a variable. !Remember, a box tuple goes up to, but
                              does NOT include the final right and bottom numbers, kinda like the range() iterator.
                          .copy  will return a new Image object with the same image as the Image object it was called on. Useful if you want to
                              make changes to an image but also want to keep the original.
                          .paste  takes two args, the first is the name of (another?) Image object, and a tuple representing where in the first image you want
                              to align and paste the top-left corner of the other image...   bigCatPic.paste(starImage, (30, 30))  or something similar.
                              .paste DOES modify the original image, unlike .crop.   You can "tile" images with clever use of .size and nested for loops.
                          .resize  returns a NEW Image object of the specified width and height.  It takes a two-int tuple arg representing the new w/h.
                          .rotate  takes an int or float representing how many degrees you want to rotate the Image object COUNTERclockwise.  Like .resize
                              and .crop, it returns a new Image object and does not affect the original.  !Important!  When using this method, the
                              dimentions of the canvas are NOT CHANGED at all, and so rotating an oblong image WILL result in clipping.  If you don't want
                              clipping to happen, include the keyword arg   expand=True  along with the rotation degree arg to force the canvas to expand
                              to accomodate overspill.
                          .transpose()  is for FLIPPING or MIRRORING images.  It takes an unorthodox argument, either:
                              1. .transpose(Image.FLIP_LEFT_RIGHT)      or
                              2. .transpose(Image.FLIP_TOP_BOTTOM)
                              In either case, it returns a new Image object.
                          .getpixel()  takes a tuple representing the coords of any single pixel in an Image object, and returns the RGBA tuple found there.
                          .putpixel()  is for drawing.  It takes 2 args: a tuple of the pixel you wanna color, and an RGBA tuple of the color.
                          ImageDraw  is another part of the Pillow module that allows you to draw simple shapes.  To get it started, here's the boilerplate
                              from PIL import Image, ImageDraw   <-- Import both Image, and ImageDraw.
                              im = Image.new('RGBA', (200, 200), 'white')  <-- first you need an image to work on.
                              draw = ImageDraw.Draw(im)  <--  then create an ImageDraw object from the image.  This object has the methods you need.
                              Many of these methods have a "fill" and "outline" arg that are optional keyword args and will default to white if left blank.
                          .point(xy, fill) draws individual pixels.  xy is a LIST of the points.  It can be a list of tuples or a list of x-y coord ints
                              not enclosed in tuples, (like    [x1, y1, x2, y2.....])
                          .line(xy, fill, width)  draws a line or series of lines.  xy is either a list of tuples, or a list of integers like above.
                              Each point is one of the connecting points on the lines you're drawing. (I assume contiguous?)
                          .rectangle(xy, fill, outline)  draws a rectangle.  xy is a BOX TUPLE as described earlier.
                          .ellipse(xy, fill, outline) draws an ellipse. xy is a BOX TUPLE as described earlier.
                          .polygon(xy, fill, outline) draws an arbitrary polygon.  Works just like .line, but the last point will automatically be
                              connected to the first point.
                          .text(xy, text, fill, ImageFont object) draw text.  xy is a two-int tuple specifying the upper-left corner of the text box.  the text arg
                              is a string of the message you want to type out.  fill and font are optional keyword args that are self-explanatory.
                          .textsize(text string, ImageFont object)  this method is for measuring purposes, not really for direct editing or creation.
                              What it does is return a two-int tuple of the width and height that the text in the given font WOULD be, if it were
                              written onto the image.  You can use this info to help center the text or see if it's too big to fit.
                              NOTE!! The above two methods can use an optional ImageFont object.  To get access to those, you need to import them.
                                  from PIL import ImageFont
                              once you have that, you can call the ImageFont.truetype(font file, font size) function. The font file should be a .ttf file,
                              and the size should be an int representing the font size in POINTS (not pixels).  According to the book, you don't need
                              to enter the full filepath to where the font files are, but in my case using WSL, the filepath is /mnt/c/Windows/Fonts
                          There are more drawing methods for these objects.  Find them at https://pillow.readthedocs.io/en/latest/reference/ImageDraw.html
- PyAutoGUI (dl needed)   PyAutoGUI is essentially HotKeys.  It is used to manipulate the mouse and keyboard in any way that a user could.
                              First of all, a warning.  DO NOT save a program as "pyautogui.py"  if you do, you won't be able to import the ACTUAL
                              pyautogui module, since your programs will import the file you named that instead.  Everything will break.
                              Also, for WSL installation you will need to also run     pip install python-xlib  (this is WSL specific).
                              Screen pixels increase from left to right on the x axis, and top to bottom on the y axis.
                          pyautogui.size()  will return a two-integer "named" tuple of the screen's width and height in pixels.  (A named tuple works
                              the same way as a normal tuple.)
                          pyautogui.moveTo()  will instantly move the mouse to a specified position.  Integer values for the x/y coordinates make up the
                              function's first and second arguments.  Optionally a duration integer or float keyword arg specifies the number of seconds
                              it should take to move the mouse.  As with .click() (see below) this also accepts Image objects as args.
                          pyautogui.move() is identical to the above, except that the x/y coords move the mouse that many pixels FROM ITS CURRENT POSITION
                              that means that negagive numbers are also posible.  (the duration keword arg is also available here.)
                          pyautogui.position()  will return a tuple of the mouses current x/y coords.  The neat thing about this is that it's a named tuple,
                              so if you store that tuple in a variable, you can then access the x/y attributes very easily with .x and .y respectively.
                              check this out...   p = pyautogui.postion()  (lets say the returned tuple was  (133, 244) )
                                                p[0] would give 133, and p[1] would give 244.  BUT! You can also just do  p.x  to get the 133, or p.y! Nice!
                          pyautogui.click(10, 5)  will move the mouse to (10, 5) and then click.  Alternatively, you can pass it a Box tuple (presumably received from the
                                                    .locateOnScreen method) to click in the center of that box.  Finally, you can just pass click() an Image object to have it
                                                    search for a match on the screen and click it!  How cool is that! (see .locateOnScreen for more)
                          pyautogui.mouseDown()   will click and hold the mouse button down.
                          pyautogui.mouseUp()     will release the mouse button.
                          pyautogui.doubleClick()  will double click.
                          pyautogui.rightClick()   will right click.
                          pyautogui.middleClick()  will middle click (the mousewheel I guess?)
                          pyautogui.dragTo()       will click where it currently is, and drag to the monitor position of the coords given.
                                                    it optionally includes a duration and a "button" keyword arg, if you wanted to, say, drag 
                                                    with the right mouse button instead.  As with .click() this also accepts Image objects as args.
                          pyautogui.drag()         same as above, but coords are relative to the current position, not the screen.
                          pyautogui.scroll(200)    will scroll up (if positive int is given) or down (if negative int is given) that many units.
                          pyautogui.mouseInfo()    !!  This is a tool to use when programming, not really something to include IN the program itself.  It launches a GUI mouse
                                                    tracking tool that will help you figure out the xy coordinates of stuff on your screen, as well as the pixel color, neat!
                                                    by default, the "3 second delay" is active, which allows you to click one of the various "copy" buttons, and then move your
                                                    mouse where it needs to be before the "copy" actually happens.
                          pyautogui.screenshot()   will return an Image object (which you should store in a variable) of the current screen. Then you can manipulate it with the pillow
                                                    module just like any other image.  USEFUL USAGE!  When you want to autoclick some button, but it's possible that the button
                                                    could maybe move or be covered by something like a pop-up, you can use a screenshot, check the COLOR of the pixel in that spot
                                                    and if something isn't right, stop the program or skip clicking.  But an EASIER WAY is with the next method...
                          pyautogui.pixel((50, 200))  takes a tuple of coords and it'll tell you the color of the pixel there.  It returns a tuple of RGB values (no alpha).
                          pyautogui.pixelMatchesColor()  will return True if the pixel at the given x/y coord on the screen matches the given color.  The args are as follows:
                                                    (x, y, (r, g, b))
                          pyautogui.locateOnScreen('somePic.png')  is quite interesting... it takes an image, and searches for a match of that exact image within the screen.
                                                    if it finds a match, it returns a Box tuple (talked about in the Pillow module) of 4 ints (left, top, width, height).  If it
                                                    doesn't find a match, it returns None. (It can also return a Generator object if multiple matches are found.)
                                                    BUT WAIT! THERE'S MORE!   You can use Image objects with click, moveTo and dragTo!
- help                =   Now this is neat, you can use the built in help function in the console to learn the usage of a particular built-in or
                          imported function like so...     help(pyip.inputChoice)
- itertools           =   module with additional iteration functions.
                            def get_chunks(list, chunk_size):
                              for i in range(0, len(list), chunk_size):
                                yield list[i:i + chunk_size]

STANDARD LIBRARIES    (Remember, you can use import library_name as shorthand_name to make calling the functions within easier)
Name        Description
copy        contains function for copying, useful for passing mutable data types such as lists and dictionaries.  Has .copy() and .deepcopy()
csv         contains functions for working with csvs, both with and without headers
datetime    contains functions for dates and times, (duh).
itertools   contains extra tools for iteration, like grabbing chunks from lists instead of individual items
json        contains functions for translating between JSON and python code.
logging     contains functions for debug logging quickly, like logging.basicConfig, logging.debug
math        contains functions related to math (duh).  such as round(float) and abs(int/float) which turns values positive.
os          contains stuff like os.chdir for changing the current working directory, os.mkdirs for creating directories, and os.listdir()
            also contains os.path library, which has additional methods like os.path.abspath(), os.path.isabs(), os.path.getsize()
pathlib     has stuff related to filepaths, however in the book example, you don't import the whole thing.  You use the following line:
            from pathlib import Path      <---  this shortens what we need to type later.  We can just type "Path" instead of "pathlib.Path"
pillow      (3rd-party) an image manipulation module. (aka PIL, because it's backwards compatible)
pprint      contains pprint and pformat, which help make output more readable (like printing hash data on separate lines, for example)
pyinputplus (3rd party, must download) contains various data validation shortcuts so you don't have to write them yourself.
PyPDF2      (3rd party, must download) used for working with PDF files
pyperclip   (3rd party, must download) contains functions for accessing your computers clipboard, which is handy!!
            namely,  pyperclip.copy() and pyperclip.paste()
python-docx (3rd party, must download)  Note! the download name and the import name are different.  used for working with Word docs
random      contains functions related to random number generation, such as random.randint(1, 10), random.choice(list)
re          contains functions related to regex
send2trash  (3rd party, must download) contains a safer, less "permanent" way to delete files than shutil.rmtree()
shelve      contains functions related to saving and opening files that are not just plaintext. If you want to "shelve" some variables for later.
shutil      contains functions for copying, moving, renaming and deleting files. (Short for "shell utilities")
subprocess  not sure yet, but seems to be able to schedule or launch other programs.
sys         contains functions related to the.. system? I guess? Such as sys.exit(), which will terminate the program immediately.
            (normally it terminates when it reaches the bottom.  This is useful for an infinitely looping menu that doesnt exit until the user
            selects or types "exit")
threading   related to the "subprocess" module above, dealing with scheduling and launching other programs.
time        contains functions for clocks and waiting, such as time.sleep(0.1)  (pause for 1/10 of a second)
traceback   contains functions for getting error information, namely the call stack.
zipfile     contains functions related to zipfiles and includes a data type called ZipFile, which has its own methods.

INTERNET-RELATED LIBRARIES
bs4         parses HTML documents. (Using this is better than just using Regex... less error prone.) FYI, it stands for 'Beautiful Soup 4'
ezgmail     (3rd party), used for working with gmail (duh)
ezsheets    (3rd party), used for working with google sheets
requests    downloads files and web pages from the internet.   (Works on WSL! Yay!)
selenium    launches and controls a web browser.  It can fill in forms and simulate mouse clicks in the browser. Use this when requests and bs4
            aren't enough and the website is more sophisticated (requiring login or something)
webbrowser  comes with Python an opens a browser to a specific page (...and that's about it). !! Does NOT work on WSL....

OTHER TROUBLESHOOTING AND LEARNING THROUGH TRIAL AND ERROR Stuff
--    So it seems that Rails servers can be opened through the terminal because of how Rails is optimized for web development.  Python's webbrowser
      module does not have that luxury, and lacks some inter-process communication (IPC) features that Rails has.  There are limitations to
      how the programs and executables hosted on the Windows OS and WSL can communicate and/or call one another.  Chrome, among other browsers and
      programs, is on Windows, and so it's hard (for reasons I don't fully grasp yet) for WSL to access them beyond simply launching them.
--    There is something called the $PATH environment variable that is a colon-separated list of file paths.  This is a list of DIRECTORIES (not actual
      executables or files) that should be searched (in order) when you type a command in the terminal.  Things like the basic "ls" or "mv", are
      executable files that live in /bin, and likewise, other commands like python3 or ipython3 are also executables.  Having the directories that
      these programs are stored in in the $PATH variable saves you the trouble of having to type out the full file path, and allows you to just type that
      keyword.   For files stored on the Windows side of things, you generally start the path with   /mnt/c/Users   and go from there. As an example,
      I added this -->  export PATH="$PATH:/mnt/c/Program Files/Google/Chrome/Application"    to make chrome.exe available to me from the command line.
      Also note that while you can run that command on the CLI, the effect will only be temporary.  As soon as you close the terminal or restart it,
      That addition to the $PATH will be gone.  If you want to make it permanent, you have to add that command to the .zshrc file (which I did).  Also
      note that the .zshrc file may or may not exist yet, so just create it if it doesn't.
--    Thanks to some help from Yann, I now have a solution for how to get the webbrowser.open method working.  Here's the message he sent me.
      Try the following:
      Run the command:
        ls /mnt/c/Program\ Files\ \(x86\)/Google/Chrome/Application/chrome.exe
      Did you get an error like ls: cannot access...?
      Yes, I had an error
      Run the following commands:
        echo "export BROWSER=\"/mnt/c/Program Files/Google/Chrome/Application/chrome.exe\"" >> ~/.zshrc
        echo "export GH_BROWSER=\"'/mnt/c/Program Files/Google/Chrome/Application/chrome.exe'\"" >> ~/.zshrc
      No, everything was fine
      Run the following commands:
        echo "export BROWSER=\"/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe\"" >> ~/.zshrc
        echo "export GH_BROWSER=\"'/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe'\"" >> ~/.zshrc
--    Fun shortcut!  Push f12 to open the dev tools in the browser!  Didn't know that!
--    CSS Selector trick!  From the dev tools, you can quickly copy the FULL css selector by right clicking an element, --> copy --> copy selector
