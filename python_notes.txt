- pip is the package installer for Python. pip allows you to install additional Python libraries and packages from the Python Package Index (PyPI).
  It's useful for managing dependencies in Python projects. With pip, you can install packages like NumPy, Django, Flask, etc., by running commands
  such as       pip install package_name.
- to run python programs, do   python3   followed by the filename in the command line
- REPL  stands for  Read  Evaluate  Print  Loop,  and it's a way to execute python code typed into the console and get immediate results.
- To initiate REPL,   simply type   "python3"  with nothing after it in the console.  To exit,  either do ctrl + D  or type "exit()"
- BUT!  There is a BETTER version of REPL, which is running    "ipython3"  which gives you stuff like remembering previous commands, using tab, etc.
  Exiting ipython3 is the same as the previous.
- Python is NOT as smart as Ruby, and does not assume that a string + an integer = a string (implicitly converting the integer into a string for you.)
- the "+" operator works on strings for concatenation.
- the "*" operator works on strings for MULTIPLIED concatenation! Nifty.  "Bob" * 5  --> BobBobBobBobBob
- you can put as many * as you want in str * int expressions, and it doesnt matter if they're before or after the str (or both) however you can't
  mix different operators.  For example   10 // 2 * 1 * "Bob" will not work, as the // operator is present.
- python convention is to use underscores for variable names (but this textbook uses camelcase)
- you can do comparisons between ints and floats.   (eg.  14 == 14.00     would be true.)
- comparisons between strings and non-strings will always be False.
- ORDER OF OPERATIONS  1. Math (see syntax) and comparison operators evaluate. 2. "not" operators. 3. "and" operators.  4. "or" operators are last.
  2 + 2 == 4 and not 2 + 2 == 5 or 2 * 2 == 2 + 2
  2 + 2 == 4 and not 2 + 2 == 5 or 4 == 2 + 2
  4 == 4 and not 4 == 5 or 4 == 4
  True and not False or True
  True and True or True
  True or True
  True
- HOW BLOCKS OF CODE WORK IN PYTHON:
    Blocks begin when the indentation increases.
    Blocks can contain other blocks.
    Blocks end when the indentation decreases to zero or to a containing block's indentation.
    Example below:
    name = 'Mary'
    password = 'swordfish'
    if name == 'Mary':
      print('Hello, Mary')
        if password == 'swordfish':
          print('Access granted.')
        else:
          print('Wrong password.')
- Libraries/modules are needed to access other functions in Python.  SEE LIBRARIES SECTION FOR LIST
  To include/access those functions in your program, you use the "import" keyword, the name of the module,
  and optionally, more module names separated by commas  DO NOT OVERWRITE MODULES BY GIVING YOUR FILES THE SAME NAME!!
- Keyword Arguments  ---  What is it?  Most arguments are identified by their POSITION in the parentheses, but keyword arguments are called by name
  right before the argument passed to them, like so...  print("Hello", end="")    <-- here "end" is an optional parameter being filled in. (If you careful
  to know, it declares what the final character(s) will be, replacing the default new line character. Another you could use with print() is the "sep" argument
  which replaces the default space with something else when multiple strings are given to print.
- Python Call stack is FILO, First in, Last out.  If a function calls another function, that second function is completed and returns before the first
  function can continue.  Pretty standard.  Terminology wise, when a new function is called, a "Frame Object" is added to the top of the stack.
- !!SCOPE!!   Variables that are assigned within a function call are in the "local" scope, while variables assigned OUTSIDE of any function are in the "global".
  A variable must be in one or the other, it cannot be in both.  THIS IS IMPORTANT!  Local code can READ global variables, but it cannot CHANGE/OVERWRITE
  global variables!  This means that it's OKAY to have a global and a local variable with the same name, as they won't interfere with one another.
  Finally, if you declare a local variable with the same name as a global, the local code will prioritize the local value over the global one, but if a
  variable name is used that has not yet been created locally, the function will assume its a global that you're talking about.
  Note: If you try to READ from the global version, then DECLARE the local version afterwards, you will get an error.  You can't do that.  It really is
  global or local ONLY. Not both.
  BEST PRACTICE:  Even though you technically CAN use variables with the same name... don't.  It can get confusing which variable is being referenced.
  I don't think that's the case in Ruby... I think local code CAN overwrite globals.
- FORCING a GLOBAL   In regards to scope above, if you MUST alter a global variable from within a local scope, you can do so by invoking the "global" keyword.
  At the top of the function,   use the keyword "global" followed by the name of the global variable.   This sort of "imports" the actual global variable
  into the local scope, and from there, you can set its value to something else as normal.  Doing this will NOT create a local variable with that name.


SYNTAX NOTES
printscreen =   print("")  single quotes also work.   integers without any quotes also work.
                You can pass multiple strings to print(), separated by commas, and they will be printed, separated by a space.
                You can override the default spaces and new line characters that the print() function adds by using the Keyword Arguments "sep" and "end"
                respectively, like so....    print("Hello", end="")  <-- stops console from going to next line.   print("milk", "eggs", "spam", sep=", ")
                will change   the output    "milk eggs spam"  into   "milk, eggs, spam"
interpolation =  To do interpolation, use the symbols %s, %i, or %f directly within the string-- then, after the final quotation mark (but still within
              the parentheses), type a   %    followed by ANOTHER set of parentheses within the first set of parentheses.
              Inside of the secondary parentheses you should include (in order) the values that will be filled into the string.
              The values provided as arguments can be either direct values (such as, 6,  3.14,  or "giraffe") or variable names.
concatenation =   nothing new here.  Just use ' + ' between two strings.   "I am " + "Jason"
operators =  same as usual, but there is ORDER OF OPERATION in python, and priority is as follows from top to bottom...
              ( ) parentheses.  Things inside of parentheses are evaluated first.
              **  exponent
              %  modulus (aka remaineder)
              //  Integer division/floored quotient  (it's just division, but it drops the remainder, if one exists (aka rounds down))
              /   division
              *   multiplication
              -   subtraction
              +   addition
              SO  as an example,  7 - 3 ** 2  evaluates to -2, not 16, because the exponent is evaluated FIRST.
              You can also STACK exponents, so 2 ** 2 ** 4  evaluates to 65536 (huge), not 256.  The last exponent is evaluated and THEN the result is
              treated as the exponent to the next exponent.
- variables =  works like Ruby.  Just put the variable name = value.  You don't need to specify data type.  n = 3, name = "Bob"
               naming restrictions.  1. alphanumeric and underscore only.  2. must not start with number 3. no spaces.
               variable names are CaSe SeNsItIvE
- user input = input()     you can add a message or question inside the parenthesis  input("What's your name?")
               !!IMPORTANT!!   Input will ALWAYS be a string,
- string length =   len(var)   or   len("String literal")
- array length  =   len(array)   or    len([2, 3, 4, 5])
- string/float to int  =   int(string/float)        (in Ruby it's     .to_i)   NOTE: making a float an int will always round it down.
- int/float to string  =   str(int/float)               (in Ruby it's     .to_s)
- string/int to float  =   float(int/string)           (in Ruby it's    .to_f)   NOTE:  making an int a float will add a .0 at the end.
- comments  =   use a hashtag to denote comments in python     #  this is a comments
- rounding numbers  =    round(float)  rounds to closest integer.
- absolute value    =     abs(int or float)  will turn the number positive if it is negative.
- data type check   =     type(variable_name or value)
- arrays           =     as usual, [1, 2, 3]    but they are called "lists"  ??
- booleans        =      assign with True    or   False.  fisrt letter MUST be capitalized, and you cannot use True  or  False as a variable name.
- comparisons     =      exactly the same as Ruby, Javascript, etc.     ==  !=   <    >   <=    >=
- &&              =      keyword   "and"
- ||              =      keyword   "or"
- !               =      keyword   "not"    not True    will evaluate to False.   not not not not True    will evaluate to True.
- conditionals    =      the condition followed by a COLON... (not curly brackets or parentheses)      if 5 > 4:    if "andy" == "tom":   else:
- if statements   =      Python uses  "if condition:"   "elif condition:"  and   "else:"
- while statements =     Use   "while condition:"
- break statement  =     just type the keyword  "break"  with nothing after it to exit a loop prematurely.
- (NEW!) continue  =     just type the keyword  "continue" with nothing after it.   What this does is jump to the START of the while loop prematurely.
- Falsey values    =     0  (an int)  0.0  (a float)  and  ''   (an empty string)   all evaluate to False in Python.
- For  loop        =     Example-     for i in range(5):          the part  "in range(5)"  is unique.   It sets the falue of i to 0 initially,
                         then counts 5 times, so i will equal    i = 0,  i = 1, i = 2, i = 3, i = 4   stop.
                         Note:  The "continue" statement in a For loop will ITERATE and then jump to the start.
                         Also, be careful... the variable name you give the incrementor (such as "i") is apparently VISIBLE to code OUTSIDE of that loop!
- More about range()  =  The range() function can have 1, 2, or 3 arguments.  If it has only 1 argument, then the range is assumed to start at 0, and
                         stops just before the argument given.  If TWO arguments are given, then the first argument becomes the STARTING point, and that
                         is used instead of 0.  If THREE arguments are used, the third argument is the "step" setting, or maybe think of it as the interval.
                         It's the number of steps that the iteration skips over.  Examples:
                         range(11) produces 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
                         range(5, 11) produces  5, 6, 7, 8, 9, 10   <---Note that it produces 5, but not 10.
                         range(5, 11, 2)  produces  5, 7, 9  <-----Note that "10" is not produced because the last "skip" would skip past the end.
                         This function is for int  only, it will not work with floats.  You can, however, use negative numbers, and even count backwards.
- rand()                 (must import random library) random.randint(start, end)  The arguments are inclusive, so the start and end numbers can appear as results.
- create a function   =  use the "def" keyword, followed by the name of the function, parentheses, and a colon.     def hello():
                         To add parameters to your function, simply add one or more variable names in the parentheses, separated by commas.
                         It looks like you don't need to declare what data type your parameters can accept... HOWEVER, how those variables are used within
                         the function block will of course expect the values to be of a certain type... So it looks like it's up to the coder to keep
                         track of this.
- return values       =  In Python, you must explicitly use the "return" keyword followed by a value or an expression (that will be evaluated).
                         Note that the "return" line immediately exits the function, ignoring anything below that line.
                         Note that you can pass return values as arguments to other functions.
                         Any function that does not explicitly return anything, will return "None" by default (see next).  Likewise, when "return" is used
                         without anything after it, the result will also be "None".
- Nil/Null            =  In Python, the "lack of any value" value is called "None" (with a capital N).  None is its own data type, and is the only value possible.
- Error Handling      =  Use the "try" and "except" statements.  Code that could potentially throw an error is put into a "try" clause.  Then, if an error
                         DOES occur, rather than crashing, the code moves to the following "except" block.  For example, try dividing by zero....
                         def spam(divided_by):
                             try:
                                 return 42 / divided_by
                             except ZeroDivisionError:
                                 print("Error: Invalid argument.")
                         Note: When an error does occur, the code does NOT jump back into the "try" block.  It just keeps going from the except block.
                         Also note that you need the NAME of the error to use the "except" clause.  Here are some names I've encountered.
                         ZeroDivisionError, UnboundLocalError, TypeError, SyntaxError

STANDARD LIBRARIES
Name        Description
random      contains functions related to random number generation, such as random.randint(1, 10)
sys         contains functions related to the.. system? I guess? Such as sys.exit(), which will terminate the program immediately.
            (normally it terminates when it reaches the bottom.  This is useful for an infinitely looping menu that doesnt exit until the user
            selects or types "exit")
os
math        contains functions related to math (duh).  such as round(float) and abs(int/float) which turns values positive.
